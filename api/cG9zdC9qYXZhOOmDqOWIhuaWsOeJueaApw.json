{"title":"java8新特性lambda表达式、方法引用、函数式接口、默认方式、静态方法","date":"2019-05-20T01:00:00.000Z","slug":"java8部分新特性","tags":["Lambda","java"],"categories":["java"],"updated":"2019-05-20T00:52:05.100Z","content":"<h1 id=\"lambda-表达式\">lambda 表达式<a href=\"post/java8部分新特性#lambda-表达式\"></a></h1><h2 id=\"线程的用法\">线程的用法<a href=\"post/java8部分新特性#线程的用法\"></a></h2><p>原始的线程用法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用匿名内部类的方式启动多线程</span><br><span class=\"line\">new Thread(new Runnable() &#123;</span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        System.out.println(&quot;这是使用匿名内部类的方式。。。&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<p>lambda表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用lambda表达式方式</span><br><span class=\"line\">new Thread(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(&quot;这是使用lambda表达式的方式。。。&quot;);</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n<h2 id=\"遍历方式\">遍历方式<a href=\"post/java8部分新特性#遍历方式\"></a></h2><p>原始方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//原始方式</span><br><span class=\"line\">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class=\"line\">for (int i : list) &#123;</span><br><span class=\"line\">    System.out.println(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>lambda表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用lambda表达式代替foreach循环</span><br><span class=\"line\">Stream.of(1, 2, 3, 4, 5).forEach((x) -&gt; &#123;</span><br><span class=\"line\">    System.out.println(x);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>总结</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">([参数可选，...]) -&gt; &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"方法引用\">方法引用<a href=\"post/java8部分新特性#方法引用\"></a></h1><p>方法引用其实是 lambda 表达式的部分的简化。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test_method_reference() &#123;</span><br><span class=\"line\">    //使用lambda表达式</span><br><span class=\"line\">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class=\"line\">        .map(s -&gt; s.length()) //lambda</span><br><span class=\"line\">        .forEach((x) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(x);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用静态方法引用</span><br><span class=\"line\">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class=\"line\">        .map(String::length) //静态方法引用</span><br><span class=\"line\">        .forEach((x) -&gt; &#123;</span><br><span class=\"line\">            System.out.println(x);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用实例方法引用</span><br><span class=\"line\">    Stream.of(</span><br><span class=\"line\">        new ClassMate(&quot;1&quot;, &quot;欧阳思海&quot;),</span><br><span class=\"line\">        new ClassMate(&quot;2&quot;, &quot;sihai&quot;)</span><br><span class=\"line\">    ).map(ClassMate::getName)//实例方法引用</span><br><span class=\"line\">        .forEach(x -&gt; &#123;</span><br><span class=\"line\">            System.out.println(x);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>第一个使用lambda表达式获取每个字符串的长度s -&gt; s.length()<br>第二个使用静态方法获取每个字符串的长度String::length<br>第三个使用实例方法引用ClassMate::getName</p>\n</blockquote>\n<p>解释</p>\n<ul>\n<li>map方法是映射的意思</li>\n<li>forEach方法是遍历每一个元素</li>\n</ul>\n<p>总结</p>\n<blockquote>\n<p>使用方法 类名::方法</p>\n</blockquote>\n<blockquote>\n<p>方法可以是静态方法和实例方法</p>\n</blockquote>\n<h1 id=\"构造函数引用\">构造函数引用<a href=\"post/java8部分新特性#构造函数引用\"></a></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">public void test_method_reference2() &#123;</span><br><span class=\"line\">    //使用lambda表达式</span><br><span class=\"line\">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class=\"line\">        .map(s -&gt; new ClassMate(s)) //lambda</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\"></span><br><span class=\"line\">    //使用构造函数引用</span><br><span class=\"line\">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class=\"line\">        .map(ClassMate::new) //构造函数引用,由上下文决定用哪一个构造函数</span><br><span class=\"line\">        .collect(Collectors.toList());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>第一个我们使用的是 lambda 表达式进行创建对象的 s -&gt; new ClassMate(s)。</p>\n</blockquote>\n<blockquote>\n<p>第二个我们使用的是构造函数引用创建对象的 ClassMate::new 。</p>\n</blockquote>\n<blockquote>\n<p>我们发现构造函数引用：类名::new ，然后对于使用哪一个构造函数是由上下文决定的，比如有一个参数和两个参数和无参数的构造函数，会自动确定用哪一个。</p>\n</blockquote>\n<h1 id=\"接口\">接口<a href=\"post/java8部分新特性#接口\"></a></h1><p>在 Java 8 之前的接口是不能有实现的，只能定义抽象方法，然而，在 Java 8 以后，增加了一个新的功能，可以添加实现，可以定义默认方法，可以定义静态方法。</p>\n<h2 id=\"函数式接口\">函数式接口<a href=\"post/java8部分新特性#函数式接口\"></a></h2><p>在一个接口中我们以 @FunctionalInterface 注解声明一个接口，并且接口中只有一个抽象方法，那么我们就叫做这是一个函数式接口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface FunctionalInterfaceTest &#123;</span><br><span class=\"line\">    //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口</span><br><span class=\"line\">    void test(String s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"默认方法\">默认方法<a href=\"post/java8部分新特性#默认方法\"></a></h2><p>默认方法很简单，用 default 声明即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface FunctionalInterfaceTest &#123;</span><br><span class=\"line\">    //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口</span><br><span class=\"line\">    void test(String s);</span><br><span class=\"line\"></span><br><span class=\"line\">    //默认方法</span><br><span class=\"line\">    default String getStr()&#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"静态方法\">静态方法<a href=\"post/java8部分新特性#静态方法\"></a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\">public interface FunctionalInterfaceTest &#123;</span><br><span class=\"line\">    //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口</span><br><span class=\"line\">    void test(String s);</span><br><span class=\"line\"></span><br><span class=\"line\">    //静态方法</span><br><span class=\"line\">    static String getStr()&#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //错误用法</span><br><span class=\"line\">    default static String getStr3()&#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>实现的静态方法，用 static 声明。</p>\n</blockquote>\n<blockquote>\n<p>注意不能同时使用 default 和 static 声明。</p>\n</blockquote>\n","prev":{"title":"http and https","slug":"httpandhttps"},"next":{"title":"Field类","slug":"Field"},"link":"http://yoursite.com/post/java8部分新特性/","toc":[{"title":"lambda 表达式","id":"lambda-表达式","index":"1","children":[{"title":"线程的用法","id":"线程的用法","index":"1.1"},{"title":"遍历方式","id":"遍历方式","index":"1.2"}]},{"title":"方法引用","id":"方法引用","index":"2"},{"title":"构造函数引用","id":"构造函数引用","index":"3"},{"title":"接口","id":"接口","index":"4","children":[{"title":"函数式接口","id":"函数式接口","index":"4.1"},{"title":"默认方法","id":"默认方法","index":"4.2"},{"title":"静态方法","id":"静态方法","index":"4.3"}]}]}