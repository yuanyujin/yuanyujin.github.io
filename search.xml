<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rocketmq安装</title>
      <link href="/2019/08/19/rocketmq%E5%AE%89%E8%A3%85/"/>
      <url>/2019/08/19/rocketmq%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="RocketMQ简介">RocketMQ简介<a href="post/rocketmq安装#RocketMQ简介"></a></h1><p>RocketMQ是阿里巴巴中间件开发的分布式消息系统，曾经经历过很多阿里巴巴大型项目的实际检验。在去年已经正式捐献给Apache开源基金会，成为孵化项目。今年正式升级成为了apache的顶级项目。</p><p>RocketMQ官网地址为：<a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">http://rocketmq.apache.org/</a><br>感兴趣的可以多多查看官网文档</p><h1 id="准备工作">准备工作<a href="post/rocketmq安装#准备工作"></a></h1><h2 id="安装环境">安装环境<a href="post/rocketmq安装#安装环境"></a></h2><p>本文所安装的RocketMQ为4.2.0版本，Linux系统版本为CentOS 7.2，安装目录为/usr/local/software/</p><h2 id="准备工具">准备工具<a href="post/rocketmq安装#准备工具"></a></h2><h3 id="Java">Java<a href="post/rocketmq安装#Java"></a></h3><p>rocketMQ是使用Java开发的，所以需要在Linux系统内安装Java环境。</p><h3 id="Maven">Maven<a href="post/rocketmq安装#Maven"></a></h3><p>项目下载下来之后需要使用Maven编译，所以需要提前安装。</p><h1 id="安装RocketMQ">安装RocketMQ<a href="post/rocketmq安装#安装RocketMQ"></a></h1><h2 id="下载RocketMQ">下载RocketMQ<a href="post/rocketmq安装#下载RocketMQ"></a></h2><ul><li><blockquote><p>wget <a href="https://github.com/apache/rocketmq/archive/rocketmq-all-4.2.0.tar.gz" target="_blank" rel="noopener">https://github.com/apache/rocketmq/archive/rocketmq-all-4.2.0.tar.gz</a></p></blockquote></li><li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/</a></p></li></ul><h2 id="解压文件">解压文件<a href="post/rocketmq安装#解压文件"></a></h2><blockquote><p>tar -zxvf rocketmq-all-4.2.0.tar.gz</p></blockquote><h2 id="编译项目">编译项目<a href="post/rocketmq安装#编译项目"></a></h2><blockquote><p>mvn -Prelease-all -DskipTests clean install -U</p></blockquote><h2 id="配置环境变量">配置环境变量<a href="post/rocketmq安装#配置环境变量"></a></h2><h3 id="编辑-etc-profile">编辑/etc/profile<a href="post/rocketmq安装#编辑-etc-profile"></a></h3><blockquote><p>export rocketmq=/usr/local/software/rocketmq-rocketmq-all-4.2.0/distribution/target/apache-rocketmq</p></blockquote><blockquote><p>export PATH= $ PATH:$rocketmq/bin</p></blockquote><h3 id="刷新环境变量">刷新环境变量<a href="post/rocketmq安装#刷新环境变量"></a></h3><blockquote><p>source /etc/profile</p></blockquote><h2 id="启动Nameserver">启动Nameserver<a href="post/rocketmq安装#启动Nameserver"></a></h2><blockquote><p>nohup sh mqnamesrv &gt;/usr/local/logs/rocketmqlogs/mqnamesrv.log 2&gt;&amp;1 &amp;</p></blockquote><h2 id="启动Broker">启动Broker<a href="post/rocketmq安装#启动Broker"></a></h2><blockquote><p>nohup sh mqbroker -n localhost:9876 &gt;/usr/local/logs/rocketmqlogs/broker.log 2&gt;&amp;1 &amp;</p></blockquote><h1 id="安装问题">安装问题<a href="post/rocketmq安装#安装问题"></a></h1><h2 id="内存分配问题">内存分配问题<a href="post/rocketmq安装#内存分配问题"></a></h2><p>修改runserver.sh和runbroker.sh两个文件</p><blockquote><p>JAVA_OPT=”${JAVA_OPT} -server -Xms=128m -Xmx=128m -Xmn=128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> rocketmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java性能优化</title>
      <link href="/2019/07/18/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/07/18/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="尽量指定类、方法的final修饰符">尽量指定类、方法的final修饰符<a href="post/性能优化#尽量指定类、方法的final修饰符"></a></h3><p>带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。</p><h3 id="尽量重用对象">尽量重用对象<a href="post/性能优化#尽量重用对象"></a></h3><p>特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p><h3 id="尽可能使用局部变量">尽可能使用局部变量<a href="post/性能优化#尽可能使用局部变量"></a></h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p><h3 id="及时关闭流">及时关闭流<a href="post/性能优化#及时关闭流"></a></h3><p>Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p><h3 id="尽量减少对变量的重复计算">尽量减少对变量的重复计算<a href="post/性能优化#尽量减少对变量的重复计算"></a></h3><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。</p><p>所以例如下面的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; list.size(); i++)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>建议替换为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0, length = list.size(); i &lt; length; i++)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure></p><p>这样，在list.size()很大的时候，就减少了很多的消耗</p><h3 id="尽量采用懒加载的策略，即在需要的时候才创建">尽量采用懒加载的策略，即在需要的时候才创建<a href="post/性能优化#尽量采用懒加载的策略，即在需要的时候才创建"></a></h3><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;aaa&quot;;</span><br><span class="line">if (i == 1)</span><br><span class="line">&#123;</span><br><span class="line">　　list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>建议替换为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (i == 1)</span><br><span class="line">&#123;</span><br><span class="line">　　String str = &quot;aaa&quot;;</span><br><span class="line">　　list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="慎用异常">慎用异常<a href="post/性能优化#慎用异常"></a></h3><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><h3 id="不要在循环中使用try…catch…，应该把其放在最外层">不要在循环中使用try…catch…，应该把其放在最外层<a href="post/性能优化#不要在循环中使用try…catch…，应该把其放在最外层"></a></h3><p>根据网友们提出的意见，这一点我认为值得商榷，欢迎大家提出看法！</p><h3 id="如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度">如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度<a href="post/性能优化#如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度"></a></h3><p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：</p><ul><li>StringBuilder()// 默认分配16个字符的空间</li><li>StringBuilder(int size)　　// 默认分配size个字符的空间</li><li>StringBuilder(String str)　// 默认分配16个字符+str.length()个字符空间</li></ul><p>可以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。</p><p>因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p><p>在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间<br>把原来的4096个字符拷贝到新的的字符数组中去<br>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。</p><p>但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</p><h3 id="当复制大量数据时，使用System-arraycopy-命令">当复制大量数据时，使用System.arraycopy()命令<a href="post/性能优化#当复制大量数据时，使用System-arraycopy-命令"></a></h3><h3 id="乘法和除法使用移位操作">乘法和除法使用移位操作<a href="post/性能优化#乘法和除法使用移位操作"></a></h3><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (val = 0; val &lt; 100000; val += 5)</span><br><span class="line">&#123;</span><br><span class="line">　　a = val * 8;</span><br><span class="line">　　b = val / 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (val = 0; val &lt; 100000; val += 5)</span><br><span class="line">&#123;</span><br><span class="line">　　a = val &lt;&lt; 3;</span><br><span class="line">　　b = val &gt;&gt; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p><h3 id="循环内不要不断创建对象引用">循环内不要不断创建对象引用<a href="post/性能优化#循环内不要不断创建对象引用"></a></h3><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Object obj = new Object();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = null;</span><br><span class="line">for (int i = 0; i &lt;= count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    obj = new Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p><h3 id="基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList">基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList<a href="post/性能优化#基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList"></a></h3><h3 id="尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销">尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销<a href="post/性能优化#尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销"></a></h3><h3 id="不要将数组声明为public-static-final">不要将数组声明为public static final<a href="post/性能优化#不要将数组声明为public-static-final"></a></h3><p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p><h3 id="尽量在合适的场合使用单例">尽量在合适的场合使用单例<a href="post/性能优化#尽量在合适的场合使用单例"></a></h3><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p><p>控制资源的使用，通过线程同步来控制资源的并发访问<br>控制实例的产生，以达到节约资源的目的<br>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</p><h3 id="尽量避免随意使用静态变量">尽量避免随意使用静态变量<a href="post/性能优化#尽量避免随意使用静态变量"></a></h3><p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class A</span><br><span class="line">&#123;</span><br><span class="line">    private static B b = new B();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止</p><h3 id="及时清除不再需要的会话">及时清除不再需要的会话<a href="post/性能优化#及时清除不再需要的会话"></a></h3><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。</p><h3 id="实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历">实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历<a href="post/性能优化#实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历"></a></h3><p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。</p><p>实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。</p><p>可以使用类似如下的代码作判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (list instanceof RandomAccess)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterable();</span><br><span class="line">    while (iterator.hasNext())&#123;iterator.next()&#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>foreach循环的底层实现原理就是迭代器Iterator，可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p><p><a href="http://www.cnblogs.com/xrq730/p/4868465.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4868465.html</a></p><h3 id="使用同步代码块替代同步方法">使用同步代码块替代同步方法<a href="post/性能优化#使用同步代码块替代同步方法"></a></h3><p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p><p><a href="http://www.cnblogs.com/xrq730/p/4851530.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4851530.html</a></p><h3 id="将常量声明为static-final，并以大写命名">将常量声明为static final，并以大写命名<a href="post/性能优化#将常量声明为static-final，并以大写命名"></a></h3><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p><h3 id="不要创建一些不使用的对象，不要导入一些不使用的类">不要创建一些不使用的对象，不要导入一些不使用的类<a href="post/性能优化#不要创建一些不使用的对象，不要导入一些不使用的类"></a></h3><p>这毫无意义，如果代码中出现The value of the local variable i is not used”、”The import java.util is never used，那么请删除这些无用的内容</p><h3 id="程序运行过程中避免使用反射">程序运行过程中避免使用反射<a href="post/性能优化#程序运行过程中避免使用反射"></a></h3><p>反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p><p><a href="http://www.cnblogs.com/xrq730/p/4862111.html" target="_blank" rel="noopener">http://www.cnblogs.com/xrq730/p/4862111.html</a></p><h3 id="使用数据库连接池和线程池">使用数据库连接池和线程池<a href="post/性能优化#使用数据库连接池和线程池"></a></h3><p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p><h3 id="使用带缓冲的输入输出流进行IO操作">使用带缓冲的输入输出流进行IO操作<a href="post/性能优化#使用带缓冲的输入输出流进行IO操作"></a></h3><p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率</p><h3 id="顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList">顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList<a href="post/性能优化#顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList"></a></h3><p>这个，理解ArrayList和LinkedList的原理就知道了</p><h3 id="不要让public方法中有太多的形参">不要让public方法中有太多的形参<a href="post/性能优化#不要让public方法中有太多的形参"></a></h3><p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p><p>违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合<br>参数太多势必导致方法调用的出错概率增加<br>至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参</p><h3 id="字符串变量和字符串常量equals的时候将字符串常量写在前面">字符串变量和字符串常量equals的时候将字符串常量写在前面<a href="post/性能优化#字符串变量和字符串常量equals的时候将字符串常量写在前面"></a></h3><p>这是一个比较常见的小技巧了，如果有以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line">if (str.equals(&quot;123&quot;))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line">if (&quot;123&quot;.equals(str))</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这么做主要是可以避免空指针异常</p><h3 id="请知道，在java中if-i-1-和if-1-i-是没有区别的，但从阅读习惯上讲，建议使用前者">请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者<a href="post/性能优化#请知道，在java中if-i-1-和if-1-i-是没有区别的，但从阅读习惯上讲，建议使用前者"></a></h3><p>平时有人问，if (i == 1)和if (1== i)有没有区别，这就要从C/C++讲起。</p><p>在C/C++中，if (i == 1)判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">if (i == 1)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C/C++判断i==1不成立，所以以0表示，即false。但是如果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">if (i = 1)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>万一程序员一个不小心，把if (i == 1)写成if (i = 1)，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">if (1 == i)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，即使开发者不小心写成了1 = i，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。</p><p>但是，在Java中，C/C++这种if (i = 1)的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错Type mismatch: cannot convert from int to boolean。但是，尽管Java的if (i == 1)和if (1 == i)在语义上没有任何区别，从阅读习惯上讲，建议使用前者会更好些。</p><h3 id="不要对数组使用toString-方法">不要对数组使用toString()方法<a href="post/性能优化#不要对数组使用toString-方法"></a></h3><p>看一下对数组使用toString()打印出来的是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    int[] is = new int[]&#123;1, 2, 3&#125;;</span><br><span class="line">    System.out.println(is.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是：</p><p>[I@18a992f<br>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections<e>重写了Object的toString()方法。</e></p><h3 id="不要对超出范围的基本数据类型做向下强制转型">不要对超出范围的基本数据类型做向下强制转型<a href="post/性能优化#不要对超出范围的基本数据类型做向下强制转型"></a></h3><p>这绝不会得到想要的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    long l = 12345678901234L;</span><br><span class="line">    int i = (int)l;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可能期望得到其中的某几位，但是结果却是：<br>1942892530</p><p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：<br>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010<br>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：<br>0111 0011 1100 1110 0010 1111 1111 0010<br>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。</p><p>从这个例子上还能顺便得到两个结论：</p><p>整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成float f = 3.5f<br>接下来再写一句int ii = l + i;会报错，因为long + int是一个long，不能赋值给int</p><h3 id="公用的集合类中不使用的数据一定要及时remove掉">公用的集合类中不使用的数据一定要及时remove掉<a href="post/性能优化#公用的集合类中不使用的数据一定要及时remove掉"></a></h3><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p><h3 id="把一个基本数据类型转为字符串，基本数据类型-toString-是最快的方式、String-valueOf-数据-次之、数据-””最慢">把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢<a href="post/性能优化#把一个基本数据类型转为字符串，基本数据类型-toString-是最快的方式、String-valueOf-数据-次之、数据-””最慢"></a></h3><p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式</p><p>三种方式的效率如何，看一个测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    int loopTime = 50000;</span><br><span class="line">    Integer i = 0;</span><br><span class="line">    long startTime = System.currentTimeMillis();</span><br><span class="line">    for (int j = 0; j &lt; loopTime; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        String str = String.valueOf(i);</span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(&quot;String.valueOf()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    for (int j = 0; j &lt; loopTime; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        String str = i.toString();</span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(&quot;Integer.toString()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    for (int j = 0; j &lt; loopTime; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        String str = i + &quot;&quot;;</span><br><span class="line">    &#125;    </span><br><span class="line">    System.out.println(&quot;i + \&quot;\&quot;：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf()：11ms</span><br><span class="line">Integer.toString()：5ms</span><br><span class="line">i + &quot;&quot;：25ms</span><br></pre></td></tr></table></figure></p><p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。</p><p>至于为什么，很简单：String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断<br>Integer.toString()方法就不说了，直接调用了<br>i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串<br>三者对比下来，明显是2最快、1次之、3最慢</p><h3 id="使用最有效率的方式去遍历Map">使用最有效率的方式去遍历Map<a href="post/性能优化#使用最有效率的方式去遍历Map"></a></h3><p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();</span><br><span class="line">    hm.put(&quot;111&quot;, &quot;222&quot;);</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator();</span><br><span class="line">    while (iter.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        Map.Entry&lt;String, String&gt; entry = iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + &quot;\t&quot; + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你只是想遍历一下这个Map的key值，那用Set<string> keySet = hm.keySet();会比较合适一些</string></p><h3 id="对资源的close-建议分开操作">对资源的close()建议分开操作<a href="post/性能优化#对资源的close-建议分开操作"></a></h3><p>意思是，比如我有这么一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>建议修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了catch块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉</p><h3 id="对于ThreadLocal使用前或者使用后一定要先remove">对于ThreadLocal使用前或者使用后一定要先remove<a href="post/性能优化#对于ThreadLocal使用前或者使用后一定要先remove"></a></h3><p>当前基本所有的项目都使用了线程池技术，这非常好，可以动态配置线程数、可以重用线程。</p><p>然而，如果你在项目中使用到了ThreadLocal，一定要记得使用前或者使用后remove一下。这是因为上面提到了线程池技术做的是一个线程重用，这意味着代码运行过程中，一条线程使用完毕，并不会被销毁而是等待下一次的使用。我们看一下Thread类中，持有ThreadLocal.ThreadLocalMap的引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="line"> by the ThreadLocal class. */</span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = null;</span><br></pre></td></tr></table></figure></p><p>线程不销毁意味着上条线程set的ThreadLocal.ThreadLocalMap中的数据依然存在，那么在下一条线程重用这个Thread的时候，很可能get到的是上条线程set的数据而不是自己想要的内容。</p><p>这个问题非常隐晦，一旦出现这个原因导致的错误，没有相关经验或者没有扎实的基础非常难发现这个问题，因此在写代码的时候就要注意这一点，这将给你后续减少很多的工作量。</p><h3 id="切记以常量定义的方式替代魔鬼数字，魔鬼数字的存在将极大地降低代码可读性，字符串常量是否使用常量定义可以视情况而定">切记以常量定义的方式替代魔鬼数字，魔鬼数字的存在将极大地降低代码可读性，字符串常量是否使用常量定义可以视情况而定<a href="post/性能优化#切记以常量定义的方式替代魔鬼数字，魔鬼数字的存在将极大地降低代码可读性，字符串常量是否使用常量定义可以视情况而定"></a></h3><h3 id="long或者Long初始赋值时，使用大写的L而不是小写的l，因为字母l极易与数字1混淆，这个点非常细节，值得注意">long或者Long初始赋值时，使用大写的L而不是小写的l，因为字母l极易与数字1混淆，这个点非常细节，值得注意<a href="post/性能优化#long或者Long初始赋值时，使用大写的L而不是小写的l，因为字母l极易与数字1混淆，这个点非常细节，值得注意"></a></h3><h3 id="所有重写的方法必须保留-Override注解">所有重写的方法必须保留@Override注解<a href="post/性能优化#所有重写的方法必须保留-Override注解"></a></h3><p>这么做有三个原因：</p><p>清楚地可以知道这个方法由父类继承而来<br>getObject()和get0bject()方法，前者第四个字母是”O”，后者第四个子母是”0”，加了@Override注解可以马上判断是否重写成功<br>在抽象类中对方法签名进行修改，实现类会马上报出编译错误</p><h3 id="推荐使用JDK7中新引入的Objects工具类来进行对象的equals比较，直接a-equals-b-，有空指针异常的风险">推荐使用JDK7中新引入的Objects工具类来进行对象的equals比较，直接a.equals(b)，有空指针异常的风险<a href="post/性能优化#推荐使用JDK7中新引入的Objects工具类来进行对象的equals比较，直接a-equals-b-，有空指针异常的风险"></a></h3><h3 id="循环体内不要使用”-”进行字符串拼接，而直接使用StringBuilder不断append">循环体内不要使用”+”进行字符串拼接，而直接使用StringBuilder不断append<a href="post/性能优化#循环体内不要使用”-”进行字符串拼接，而直接使用StringBuilder不断append"></a></h3><p>说一下不使用”+”进行字符串拼接的原因，假如我有一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String appendStr(String oriStr, String... appendStrs) &#123;</span><br><span class="line">    if (appendStrs == null || appendStrs.length == 0) &#123;</span><br><span class="line">        return oriStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (String appendStr : appendStrs) &#123;</span><br><span class="line">        oriStr += appendStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return oriStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这段代码编译之后的.class文件，使用javap -c进行反编译一下，截取关键的一部分：</p><p>意思就是每次虚拟机碰到”+”这个操作符对字符串进行拼接的时候，会new出一个StringBuilder，然后调用append方法，最后调用toString()方法转换字符串赋值给oriStr对象，即循环多少次，就会new出多少个StringBuilder()来，这对于内存是一种浪费。</p><h3 id="不捕获Java类库中定义的继承自RuntimeException的运行时异常类">不捕获Java类库中定义的继承自RuntimeException的运行时异常类<a href="post/性能优化#不捕获Java类库中定义的继承自RuntimeException的运行时异常类"></a></h3><p>异常处理效率低，RuntimeException的运行时异常类，其中绝大多数完全可以由程序员来规避，比如：</p><p>ArithmeticException可以通过判断除数是否为空来规避<br>NullPointerException可以通过判断对象是否为空来规避<br>IndexOutOfBoundsException可以通过判断数组/字符串长度来规避<br>ClassCastException可以通过instanceof关键字来规避<br>ConcurrentModificationException可以使用迭代器来规避</p><h3 id="避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降，JDK7之后，可以使用ThreadLocalRandom来获取随机数">避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降，JDK7之后，可以使用ThreadLocalRandom来获取随机数<a href="post/性能优化#避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed-导致的性能下降，JDK7之后，可以使用ThreadLocalRandom来获取随机数"></a></h3><p>解释一下竞争同一个seed导致性能下降的原因，比如，看一下Random类的nextInt()方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int nextInt() &#123;</span><br><span class="line">    return next(32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了next(int bits)方法，这是一个受保护的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected int next(int bits) &#123;</span><br><span class="line">    long oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = this.seed;</span><br><span class="line">    do &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; while (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这边的seed是一个全局变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The internal state associated with this pseudorandom number generator.</span><br><span class="line"> * (The specs for the methods in this class describe the ongoing</span><br><span class="line"> * computation of this value.)</span><br><span class="line"> */</span><br><span class="line">private final AtomicLong seed;</span><br></pre></td></tr></table></figure><p>多个线程同时获取随机数的时候，会竞争同一个seed，导致了效率的降低。</p><h3 id="静态类、单例类、工厂类将它们的构造函数置为private">静态类、单例类、工厂类将它们的构造函数置为private<a href="post/性能优化#静态类、单例类、工厂类将它们的构造函数置为private"></a></h3><p>这是因为静态类、单例类、工厂类这种类本来我们就不需要外部将它们new出来，将构造函数置为private之后，保证了这些类不会产生实例对象。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http and https</title>
      <link href="/2019/05/31/httpandhttps/"/>
      <url>/2019/05/31/httpandhttps/</url>
      
        <content type="html"><![CDATA[<h1 id="网络层结构">网络层结构<a href="post/httpandhttps#网络层结构"></a></h1><ul><li>OSI是指Open System Interconnect，意为开放式系统互联。</li><li>TCP/IP是指传输控制协议/网间协议，是目前世界上应用最广的协议</li></ul><div class="article-bounded"><div class="article-table"><table><thead><tr><th>对应tcp/ip层</th><th style="text-align:center">osi各层功能</th><th style="text-align:right">网络协议</th></tr></thead><tbody><tr><td>应用层</td><td style="text-align:center">应用程序（电子邮件、文件服务）、用户接口</td><td style="text-align:right">HTTP、FTP、TFTP、NFS</td></tr><tr><td>应用层</td><td style="text-align:center">数据的表示、压缩和加密（数据格式化、代码转换、数据加密）</td><td style="text-align:right">TELNET、SNMP</td></tr><tr><td>应用层</td><td style="text-align:center">建立、管理和终止会话</td><td style="text-align:right">SMTP、DNS</td></tr><tr><td>传输层</td><td style="text-align:center">提供端到端可靠报文传递和错误恢复</td><td style="text-align:right">TCP、UDP</td></tr><tr><td>国际互联层</td><td style="text-align:center">提供数据包从源到宿的传递和网际交互</td><td style="text-align:right">IP、ICMP、ARP、RARP、UUCP</td></tr><tr><td>网络接口层</td><td style="text-align:center">将比特组装成桢和点到点传递</td><td style="text-align:right">FDDI、SLIP、PPP、PDN</td></tr><tr><td>网络接口层</td><td style="text-align:center">传输比特流，以二进制数据形式在物理媒体上传输数据</td><td style="text-align:right">ISO2110、IEEE802、IEEE802.2</td></tr></tbody></table></div></div><h2 id="两种模型的区别">两种模型的区别<a href="post/httpandhttps#两种模型的区别"></a></h2><ul><li>OSI采用七层模型，TCP/IP采用四层模型。</li><li>TCP/IP网络接口层没有真正的定义，只是概念性的描述。OSI把它分为2层，每一层功能详尽。</li><li>在协议开发之前，就有了OSI模型，所以OSI模型具有共通性，而TCP/IP是基于协议建立的模型，不适用于非TCP/IP的网络。</li><li>实际应用中，OSI模型是理论上的模型，没有成熟的产品；而TCP/IP已经成为国际标准。</li></ul><h1 id="HTTP协议">HTTP协议<a href="post/httpandhttps#HTTP协议"></a></h1><p>Http是基于TCP/IP协议的应用程序协议，不包括数据包的传输，主要规定了客户端和服务器的通信格式，默认使用80端口。</p><h2 id="发展历史">发展历史<a href="post/httpandhttps#发展历史"></a></h2><ul><li>1991年发布Http/0.9版本，只有Get命令，且服务端直返HTML格式字符串，服务器响应完毕就关闭TCP连接。</li><li>1996年发布Http/1.0版本，优点：可以发送任何格式内容，包括文字、图像、视频、二进制。也丰富了命令Get，Post，Head。请求和响应的格式加入头信息。缺点：每个TCP连接只能发送一个请求，而新建TCP连接的成本很高，导致Http/1.0新能很差。</li><li>1997发布Http/1.1版本，完善了Http协议，直至20年后的今天仍是最流行的版本。优点如下<ul><li>引入持久连接，TCP默认不关闭，可被多个请求复用，对于一个域名，多数浏览器允许同时建立6个持久连接。</li><li>引入管道机制，即在同一个TCP连接中，可以同时发送多个请求，不过服务器还是按顺序响应。</li><li>在头部加入Content-Length字段，一个TCP可以同时传送多个响应，所以就需要该字段来区分哪些内容属于哪个响应。</li><li>分块传输编码，对于耗时的动态操作，用流模式取代缓存模式，即产生一块数据，就发送一块数据。</li><li>增加了许多命令，头信息增加Host来指定服务器域名，可以访问一台服务器上的不同网站。</li></ul></li><li>2015年发布Http/2版本，它有几个特性：二进制协议、多工、数据流、头信息压缩、服务器推送。</li></ul><h2 id="http请求和响应格式">http请求和响应格式<a href="post/httpandhttps#http请求和响应格式"></a></h2><p>request格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /barite/account/stock/groups HTTP/1.1</span><br><span class="line">QUARTZ-SESSION: MC4xMDQ0NjA3NTI0Mzc0MjAyNg.VPXuA8rxTghcZlRCfiAwZlAIdCA</span><br><span class="line">DEVICE-TYPE: ANDROID</span><br><span class="line">API-VERSION: 15</span><br><span class="line">Host: shitouji.bluestonehk.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">User-Agent: okhttp/3.10.0</span><br></pre></td></tr></table></figure></p><p>response格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.6.3</span><br><span class="line">Date: Mon, 15 Oct 2018 03:30:28 GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Expires: Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Proxy-Connection: Keep-alive</span><br><span class="line"></span><br><span class="line">&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Host:指定服务器域名，可用来区分访问一个服务器上的不同服务</li><li>Connection：keep-alive（默认值）表示要求服务器不要关闭TCP。close表示明确要求关闭连接</li><li>Accept-Encoding：用户代理，是服务器能识别客户端的操作系统（Android，IOS，WEB）及相关的信息。作用是帮助服务器区分客户端，并且针对不同客户端让用户看到不同数据，做不同的操作。</li><li>Content-Type：服务器告诉客户端数据的格式，常见的值有text/plain、image/jpeg、image/png、video/mp4、application/json、application/zip，这些数据类型总称为MIMETYPE。</li><li>Content-Encodiing：chunked表示采用分块传输编码、有该字段则无需使用Content-Length字段。</li><li>Content-Length：声明数据的长度。请求和回应头部都可以使用该字段。</li></ul><h1 id="TCP三次握手">TCP三次握手<a href="post/httpandhttps#TCP三次握手"></a></h1><p>http和https协议请求时都会通过tcp三次握手建立tcp连接。</p><ul><li>第一次握手，A向B发送信息后，B收到消息，B可以确认A的发信能力和B的收信能力。</li><li>第二次握手，B向A发消息，A收到消息，A可确认A的发信能力和收信能力，A也可确认B的收信能力和发信能力。</li><li>第三次握手，A向B发送信息，B接收信息。B可确认A的收信能力和B的发信能力</li></ul><div class="article-img"><p><img src="https://wx2.sinaimg.cn/mw690/007hzwxWly1g3kvuneyw9j30hs0jun51.jpg" alt="TCP三次握手" title="TCP三次握手" data-zoomable></p></div><p>ACK：响应标识，1表示响应，连接建立成功后，所有的报文段ACK的值都为1</p><p>SYN：连接标识，1表示建立连接，连接请求和连接接受报文段SYN=1，其他情况都是0</p><p>FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段FIN=1，其他情况都是0，跟SYN类似。</p><p>seq number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有</p><p>ack number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段。</p><h2 id="三次握手具体流程">三次握手具体流程<a href="post/httpandhttps#三次握手具体流程"></a></h2><ul><li>第一次握手：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。</li><li>第二次握手：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack=x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq=y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。</li><li>第三次握手：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成Tcp三次握手。</li></ul><h2 id="数据传输完毕，需要断开连接，断开连接需要经历四次挥手">数据传输完毕，需要断开连接，断开连接需要经历四次挥手<a href="post/httpandhttps#数据传输完毕，需要断开连接，断开连接需要经历四次挥手"></a></h2><ul><li>第一次挥手：主机1（可以是客户端或服务器），设置seq和ack向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1状态，表示没有数据要发送给主机2了</li><li>第二次挥手：主机2收到主机1的FIN报文段，向主机1回应一个ACK报文段，表示同意关闭请求，主机1进入FIN_WAIT_2状态。</li><li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，主机2进入LAST_ACK状态。</li><li>第四次挥手：主机1收到主机2的FIN报文段，想主机2回应ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段后，关闭连接。此时主机1等待主机2一段时间后，没有收到回复，证明主机2已经正常关闭，主机1页关闭连接。</li></ul><div class="article-img"><p><img src="http://wx2.sinaimg.cn/large/007hzwxWly1g3kvuu52qsj30hs0cbadk.jpg" alt="tcp报文段的首部格式图" title="tcp报文段的首部格式图" data-zoomable></p></div><h1 id="Https协议-SSL协议">Https协议/SSL协议<a href="post/httpandhttps#Https协议-SSL协议"></a></h1><p>Https协议是以安全为目标的Http通道，简单来说就是Http的安全版。主要是在Http下加入SSL层（现在主流的是SLL/TLS），SSL是Https协议的安全基础。Https默认端口号为443。</p><blockquote><p>http风险</p></blockquote><ul><li>窃听风险：Http采用明文传输数据，第三方可以用获知通信内容</li><li>篡改风险：第三方可以修改通信内容</li><li>冒充风险：第三方可以冒充他人身份进行通信</li></ul><blockquote><p>SSL/TLS协议就是为了解决这些风险而设计</p></blockquote><ul><li>所有信息加密传输，三方窃听通信内容</li><li>具有校验机制，内容一旦被篡改，通信双发立刻会发现</li><li>配备身份证书，防止身份被冒充</li></ul><h2 id="SSL发展史">SSL发展史<a href="post/httpandhttps#SSL发展史"></a></h2><ul><li>1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。</li><li>1995年NetSpace发布SSL/2.0版本，很快发现有严重漏洞</li><li>1996年发布SSL/3.0版本，得到大规模应用</li><li>1999年，发布了SSL升级版TLS/1.0版本，目前应用最广泛的版本</li><li>2006年和2008年，发布了TLS/1.1版本和TLS/1.2版本</li></ul><h2 id="SSL原理及运行过程">SSL原理及运行过程<a href="post/httpandhttps#SSL原理及运行过程"></a></h2><p>SSL/TLS协议基本思路是采用公钥加密法（最有名的是RSA加密算法）。大概流程是，客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。</p><p>为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。</p><p>过程</p><ul><li>客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式</li><li>服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random）</li><li>客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端</li><li>服务端使用自己的私钥解密出C</li><li>客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。</li></ul><h1 id="SSL证书">SSL证书<a href="post/httpandhttps#SSL证书"></a></h1><p>SSL证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，需要从经销商购买。</p><p>证书按照认证级别分类</p><ul><li>域名认证（DV=Domain Validation）：最低级别的认证，可以确认申请人拥有这个域名</li><li>公司认证（OV=Organization Validation）：确认域名所有人是哪家公司，证书里面包含公司的信息</li><li>扩展认证（EV=Extended Validation）：最高级别认证，浏览器地址会显示公司名称</li></ul><p>按覆盖范围分类</p><ul><li>单域名证书：只能用于单域名 foo.com证书不用于<a href="http://www.foo.com" target="_blank" rel="noopener">www.foo.com</a></li><li>通配符证书：可用于某个域名及所有一级子域名，比如*.foo.com的证书可用于foo.com，也可以用于<a href="http://www.foo.com" target="_blank" rel="noopener">www.foo.com</a></li><li>多域名证书：可用于多个域名，比如foo.com和bar.com</li></ul><p>认证级别越高，覆盖范围越广的证书，价格越贵。也有免费的证书，为了推广Https，电子前哨基金会成立了Let’s Encrypt提供免费证书。</p><h1 id="RSA加密和DH加密">RSA加密和DH加密<a href="post/httpandhttps#RSA加密和DH加密"></a></h1><h2 id="加密算法分类">加密算法分类<a href="post/httpandhttps#加密算法分类"></a></h2><ul><li>对称加密：甲方和乙方使用同一种加密规则对信息加解密</li><li>非对称加密：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。</li><li>Hash加密：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程</li></ul><p>对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA</p><p>非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用（对称加密通信内容，非对称加密对称秘钥）。常见的非对称加密算法有RSA、DH、DSA、ECC</p><p>Hash算法特性是：输入值一样，经过哈希函数得到相同的散列值，但并非散列值相同则输入值也相同。常见的Hash加密算法有MD5、SHA-1、SHA-X系列</p><h1 id="Http协议和Https协议的对比">Http协议和Https协议的对比<a href="post/httpandhttps#Http协议和Https协议的对比"></a></h1><ul><li>https协议需要到CA申请证书，大多数情况下需要一定费用</li><li>Http是超文本传输协议，信息采用明文传输，Https则是具有安全性SSL加密传输协议</li><li>Http和Https端口号不一样，Http是80端口，Https是443端口</li><li>Http连接是无状态的，而Https采用Http+SSL构建可进行加密传输、身份认证的网络协议，更安全</li><li>Http协议建立连接的过程比Https协议快。因为Https除了Tcp三次握手，还要经过SSL握手。连接建立之后数据传输速度，二者无明显区别。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8新特性lambda表达式、方法引用、函数式接口、默认方式、静态方法</title>
      <link href="/2019/05/20/java8%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/05/20/java8%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="lambda-表达式">lambda 表达式<a href="post/java8部分新特性#lambda-表达式"></a></h1><h2 id="线程的用法">线程的用法<a href="post/java8部分新特性#线程的用法"></a></h2><p>原始的线程用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//使用匿名内部类的方式启动多线程</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;这是使用匿名内部类的方式。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>lambda表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用lambda表达式方式</span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;这是使用lambda表达式的方式。。。&quot;);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="遍历方式">遍历方式<a href="post/java8部分新特性#遍历方式"></a></h2><p>原始方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//原始方式</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">for (int i : list) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用lambda表达式代替foreach循环</span><br><span class="line">Stream.of(1, 2, 3, 4, 5).forEach((x) -&gt; &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">([参数可选，...]) -&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法引用">方法引用<a href="post/java8部分新特性#方法引用"></a></h1><p>方法引用其实是 lambda 表达式的部分的简化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_method_reference() &#123;</span><br><span class="line">    //使用lambda表达式</span><br><span class="line">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class="line">        .map(s -&gt; s.length()) //lambda</span><br><span class="line">        .forEach((x) -&gt; &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    //使用静态方法引用</span><br><span class="line">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class="line">        .map(String::length) //静态方法引用</span><br><span class="line">        .forEach((x) -&gt; &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    //使用实例方法引用</span><br><span class="line">    Stream.of(</span><br><span class="line">        new ClassMate(&quot;1&quot;, &quot;欧阳思海&quot;),</span><br><span class="line">        new ClassMate(&quot;2&quot;, &quot;sihai&quot;)</span><br><span class="line">    ).map(ClassMate::getName)//实例方法引用</span><br><span class="line">        .forEach(x -&gt; &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>第一个使用lambda表达式获取每个字符串的长度s -&gt; s.length()<br>第二个使用静态方法获取每个字符串的长度String::length<br>第三个使用实例方法引用ClassMate::getName</p></blockquote><p>解释</p><ul><li>map方法是映射的意思</li><li>forEach方法是遍历每一个元素</li></ul><p>总结</p><blockquote><p>使用方法 类名::方法</p></blockquote><blockquote><p>方法可以是静态方法和实例方法</p></blockquote><h1 id="构造函数引用">构造函数引用<a href="post/java8部分新特性#构造函数引用"></a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_method_reference2() &#123;</span><br><span class="line">    //使用lambda表达式</span><br><span class="line">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class="line">        .map(s -&gt; new ClassMate(s)) //lambda</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    //使用构造函数引用</span><br><span class="line">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class="line">        .map(ClassMate::new) //构造函数引用,由上下文决定用哪一个构造函数</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一个我们使用的是 lambda 表达式进行创建对象的 s -&gt; new ClassMate(s)。</p></blockquote><blockquote><p>第二个我们使用的是构造函数引用创建对象的 ClassMate::new 。</p></blockquote><blockquote><p>我们发现构造函数引用：类名::new ，然后对于使用哪一个构造函数是由上下文决定的，比如有一个参数和两个参数和无参数的构造函数，会自动确定用哪一个。</p></blockquote><h1 id="接口">接口<a href="post/java8部分新特性#接口"></a></h1><p>在 Java 8 之前的接口是不能有实现的，只能定义抽象方法，然而，在 Java 8 以后，增加了一个新的功能，可以添加实现，可以定义默认方法，可以定义静态方法。</p><h2 id="函数式接口">函数式接口<a href="post/java8部分新特性#函数式接口"></a></h2><p>在一个接口中我们以 @FunctionalInterface 注解声明一个接口，并且接口中只有一个抽象方法，那么我们就叫做这是一个函数式接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalInterfaceTest &#123;</span><br><span class="line">    //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口</span><br><span class="line">    void test(String s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认方法">默认方法<a href="post/java8部分新特性#默认方法"></a></h2><p>默认方法很简单，用 default 声明即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalInterfaceTest &#123;</span><br><span class="line">    //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口</span><br><span class="line">    void test(String s);</span><br><span class="line"></span><br><span class="line">    //默认方法</span><br><span class="line">    default String getStr()&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态方法">静态方法<a href="post/java8部分新特性#静态方法"></a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalInterfaceTest &#123;</span><br><span class="line">    //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口</span><br><span class="line">    void test(String s);</span><br><span class="line"></span><br><span class="line">    //静态方法</span><br><span class="line">    static String getStr()&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //错误用法</span><br><span class="line">    default static String getStr3()&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现的静态方法，用 static 声明。</p></blockquote><blockquote><p>注意不能同时使用 default 和 static 声明。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Field类</title>
      <link href="/2019/05/18/Field/"/>
      <url>/2019/05/18/Field/</url>
      
        <content type="html"><![CDATA[<p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p><h1 id="Field-成员变量的介绍">Field 成员变量的介绍<a href="post/Field#Field-成员变量的介绍"></a></h1><blockquote><p>每个成员变量有类型和值。java.lang.reflect.Field 为我们提供了获取当前对象的成员变量的类型，和重新设值的方法。</p></blockquote><h1 id="获取变量的类型">获取变量的类型<a href="post/Field#获取变量的类型"></a></h1><p>类中的变量分为两种类型：基本类型和引用类型：</p><ul><li>基本类型（ 8 种） <ul><li>整数：byte, short, int, long</li><li>浮点数：float, double</li><li>字符：char</li><li>布尔值：boolean</li></ul></li><li>引用类型 <ul><li>所有的引用类型都继承自 java.lang.Object</li><li>类，枚举，数组，接口都是引用类型</li><li>java.io.Serializable 接口，基本类型的包装类（比如 java.lang.Double）也是引用类型</li></ul></li></ul><p>java.lang.reflect.Field 提供了两个方法获去变量的类型：</p><blockquote><p>Field.getType()：返回这个变量的类型</p></blockquote><blockquote><p>Field.getGenericType()：如果当前属性有签名属性类型就返回，否则就返回 Field.getType()</p></blockquote><blockquote><p>field.getType()和field.getGenericType()的区别就是返回类型不一样</p></blockquote><h1 id="获取成员变量的修饰符">获取成员变量的修饰符<a href="post/Field#获取成员变量的修饰符"></a></h1><p>成员变量可以被以下修饰符修饰：</p><ul><li>访问权限控制符：public, protected, private</li><li>限制只能有一个实例的：static</li><li>不允许修改的：final</li><li>不会被序列化：transient</li><li>线程共享数据的一致性：volatile</li><li>注解</li></ul><p>类似获取 Class 的修饰符，我们可以使用 Field.getModifiers() 方法获取当前成员变量的修饰符。<br>返回 java.lang.reflect.Modifier 中定义的整形值。然后使用 Modifier.toString(int mod)解码成字符串</p><p>由于 Field 间接继承了 java.lang.reflect.AnnotatedElement ，因此运行时也可以获得修饰成员变量的注解，当然前提是这个注解被 java.lang.annotation.RetentionPolicy.RUNTIME 修饰。</p><h1 id="获取和修改成员变量的值">获取和修改成员变量的值<a href="post/Field#获取和修改成员变量的值"></a></h1><p>拿到一个对象后，我们可以在运行时修改它的成员变量的值，对运行时来说，反射修改变量值的操作和类中修改变量的结果是一样的。</p><ul><li><p>基本类型的getter方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">byte getByte(Object obj) </span><br><span class="line">    获取一个静态或实例 byte 字段的值。 </span><br><span class="line">int getInt(Object obj) </span><br><span class="line">    获取 int 类型或另一个通过扩展转换可以转换为 int 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> short getShort(Object obj) </span><br><span class="line">    获取 short 类型或另一个通过扩展转换可以转换为 short 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> long getLong(Object obj) </span><br><span class="line">    获取 long 类型或另一个通过扩展转换可以转换为 long 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> float getFloat(Object obj) </span><br><span class="line">    获取 float 类型或另一个通过扩展转换可以转换为 float 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> double getDouble(Object obj) </span><br><span class="line">    获取 double 类型或另一个通过扩展转换可以转换为 double 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> boolean getBoolean(Object obj) </span><br><span class="line">    获取一个静态或实例 boolean 字段的值。 </span><br><span class="line"> char getChar(Object obj) </span><br><span class="line">    获取 char 类型或另一个通过扩展转换可以转换为 char 类型的基本类型的静态或实例字段的值。</span><br></pre></td></tr></table></figure></li><li><p>基本类型的setter</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void setByte(Object obj, byte b) </span><br><span class="line">    将字段的值设置为指定对象上的一个 byte 值。 </span><br><span class="line"> void setShort(Object obj, short s) </span><br><span class="line">    将字段的值设置为指定对象上的一个 short 值。</span><br><span class="line"> void setInt(Object obj, int i) </span><br><span class="line">    将字段的值设置为指定对象上的一个 int 值。 </span><br><span class="line"> void setLong(Object obj, long l) </span><br><span class="line">    将字段的值设置为指定对象上的一个 long 值。 </span><br><span class="line"> void setFloat(Object obj, float f) </span><br><span class="line">    将字段的值设置为指定对象上的一个 float 值。</span><br><span class="line"> void setDouble(Object obj, double d) </span><br><span class="line">    将字段的值设置为指定对象上的一个 double 值。</span><br><span class="line"> void setBoolean(Object obj, boolean z) </span><br><span class="line">    将字段的值设置为指定对象上的一个 boolean 值。 </span><br><span class="line"> void setChar(Object obj, char c) </span><br><span class="line">    将字段的值设置为指定对象上的一个 char 值。</span><br></pre></td></tr></table></figure><ul><li>引用类型的getter</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object get(Object obj) </span><br><span class="line">    返回指定对象上此 Field 表示的字段的值。</span><br></pre></td></tr></table></figure><ul><li>引用类型的setter</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void set(Object obj, Object value) </span><br><span class="line">    将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</span><br></pre></td></tr></table></figure><blockquote><p>再说一下setAccessible()方法，Field的setAccessible()方法是从AccessibleObject类继承而来的。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。<br>它提供了在使用时 取消默认 Java 语言访问控制检查的能力。<br>一般情况下，我们并不能对类的私有字段进行操作，利用反射也不例外，但有的时候，例如要序列化的时候，我们又必须有能力去处理这些字段，这时候，我们就需要调用AccessibleObject上的setAccessible()方法来允许这种访问，而由于反射类中的Field，Method和Constructor继承自AccessibleObject，因此，通过在Field，Method和Constructor这些类上调用setAccessible()方法，我们可以操作这些字段无法访问的字段。</p></blockquote><h1 id="其他方法">其他方法<a href="post/Field#其他方法"></a></h1><ul><li>boolean</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(Object obj) </span><br><span class="line">    将此 Field 与指定对象比较。 </span><br><span class="line">boolean isEnumConstant() </span><br><span class="line">    如果此字段表示枚举类型的元素，则返回 true；否则返回 false。 </span><br><span class="line">boolean isSynthetic() </span><br><span class="line">    如果此字段是复合字段，则返回 true；否则返回 false。</span><br></pre></td></tr></table></figure><ul><li>String</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String getName() </span><br><span class="line">    返回此 Field 对象表示的字段的名称。 </span><br><span class="line">String toGenericString() </span><br><span class="line">    返回一个描述此 Field（包括其一般类型）的字符串。 </span><br><span class="line">String toString() </span><br><span class="line">    返回一个描述此 Field 的字符串。</span><br></pre></td></tr></table></figure><ul><li>其他</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int hashCode()</span><br><span class="line">    返回该 Field 的哈希码。</span><br><span class="line">boolean equals(Object obj)</span><br><span class="line">    将此 Field 与指定对象比较。</span><br></pre></td></tr></table></figure><ul><li><p>equals()和hashCode()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Annotation&gt; T  getAnnotation(Class&lt;T&gt; annotationClass)</span><br><span class="line">    如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。</span><br></pre></td></tr></table></figure></li><li><p>返回注释的方法：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] getDeclaredAnnotations()</span><br><span class="line">    返回直接存在于此元素上的所有注释。</span><br></pre></td></tr></table></figure><ul><li>返回字段所在的类或者接口的Class对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; getDeclaringClass()</span><br><span class="line">    返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段。</span><br></pre></td></tr></table></figure><ul><li>返回字段的类型（Type）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type getGenericType()</span><br><span class="line">    返回一个 Type 对象，它表示此 Field 对象所表示字段的声明类型。</span><br></pre></td></tr></table></figure><ul><li>返回修饰符编码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int getModifiers()</span><br><span class="line">    以整数形式返回由此 Field 对象表示的字段的 Java 语言修饰符。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Field </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Method类</title>
      <link href="/2019/05/18/Method/"/>
      <url>/2019/05/18/Method/</url>
      
        <content type="html"><![CDATA[<p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。</p><p>一个完整方法包含的属性有：</p><ul><li>方法上使用的注解</li><li>方法的修饰符</li><li>方法上定义的泛型参数</li><li>方法的返回值</li><li>方法名称</li><li>方法参数(泛型、注解)</li><li>方法抛出的异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotation</span><br><span class="line">public &lt;T&gt; boolean add(List&lt;T&gt; list,T...params)throws RuntimeException,Exception&#123;</span><br><span class="line">if(null==list)&#123;</span><br><span class="line">throw new RuntimeException(&quot;list=null&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(null==params)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">//将参数添加到List集合中</span><br><span class="line">if(null!=params)&#123;</span><br><span class="line">for(T t:params)&#123;</span><br><span class="line">list.add(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解：@MyAnnotation</p><p>修饰符：public</p><p>泛型参数：T</p><p>返回值：boolean</p><p>方法名：add</p><p>方法参数(泛型、注解)：List<t> list，T…params</t></p><p>抛出的异常：RuntimeException，Exception</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MethodTest &#123;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 一个完整方法包含的属性有： 方法上使用的注解、方法的修饰符、方法上定义的泛型参数、方法的返回值、方法名称、方法参数(泛型、注解)、方法抛出的异常</span><br><span class="line"> */</span><br><span class="line">@MyAnnotation</span><br><span class="line">private &lt;T&gt; boolean add(@MyAnnotation List&lt;T&gt; list, T... params) throws RuntimeException,</span><br><span class="line">Exception &#123;</span><br><span class="line">if (null == list) &#123;</span><br><span class="line">throw new RuntimeException(&quot;list=null&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (null == params) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">// 将参数添加到List集合中</span><br><span class="line">if (null != params) &#123;</span><br><span class="line">for (T t : params) &#123;</span><br><span class="line">list.add(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">// 获取Method</span><br><span class="line">MethodTest obj = new MethodTest();</span><br><span class="line">Class&lt;? extends MethodTest&gt; clazz = obj.getClass();</span><br><span class="line"> </span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;add&quot;, List.class,</span><br><span class="line">Object[].class);</span><br><span class="line">if (!method.isAccessible()) &#123;</span><br><span class="line">method.setAccessible(true);</span><br><span class="line">&#125;</span><br><span class="line">        //获取方法基本信息</span><br><span class="line">getMethodInfo(method);</span><br><span class="line"></span><br><span class="line">// 调用方法</span><br><span class="line">List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</span><br><span class="line">method.invoke(obj, arrayList, new String[] &#123; &quot;1&quot;, &quot;2&quot; &#125;);</span><br><span class="line">System.out.println(arrayList);//[1,2]</span><br><span class="line"></span><br><span class="line">//方法定义所在的类</span><br><span class="line">Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line"></span><br><span class="line">// 如果此方法是 bridge 方法，则返回 true；</span><br><span class="line">boolean bridge = method.isBridge();</span><br><span class="line">//如果该方法是public非抽象非静态，且定义在接口中，则返回true</span><br><span class="line">boolean default1 = method.isDefault(); //false</span><br><span class="line">//如果此方法为复合方法，则返回 true；</span><br><span class="line">boolean synthetic = method.isSynthetic();//false</span><br><span class="line">// 如果将此方法的参数带有可变参数，则返回 true</span><br><span class="line">boolean varArgs = method.isVarArgs(); //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static void getMethodInfo(Method method) &#123;</span><br><span class="line">// 1、获取方法上的注解</span><br><span class="line">boolean annotationPresent = method</span><br><span class="line">.isAnnotationPresent(MyAnnotation.class);</span><br><span class="line">if (annotationPresent) &#123;</span><br><span class="line">MyAnnotation myAnnotation = method</span><br><span class="line">.getDeclaredAnnotation(MyAnnotation.class);</span><br><span class="line">&#125;</span><br><span class="line">// 2、方法的修饰符</span><br><span class="line">int modifiers = method.getModifiers();</span><br><span class="line">String modify = Modifier.toString(modifiers);// private</span><br><span class="line">// 3、方法上定义的泛型参数</span><br><span class="line">TypeVariable&lt;Method&gt;[] typeParameters = method.getTypeParameters();// [T]</span><br><span class="line">// 4、方法的返回值</span><br><span class="line">Class&lt;?&gt; returnType = method.getReturnType();// boolean</span><br><span class="line">Type genericReturnType = method.getGenericReturnType();// boolean</span><br><span class="line">// 5、方法名称</span><br><span class="line">String name = method.getName();</span><br><span class="line">// 6、方法参数</span><br><span class="line">int parameterCount = method.getParameterCount();// 参数个数 2</span><br><span class="line">// 方法参数——泛型</span><br><span class="line">Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">// 打印 [interface java.util.List, class [Ljava.lang.Object;]</span><br><span class="line">Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">// 打印 [java.util.List&lt;T&gt;, T[]]</span><br><span class="line">for (Type type : genericParameterTypes) &#123;</span><br><span class="line">if (type instanceof ParameterizedType) &#123; // 参数类型</span><br><span class="line">System.out.println(&quot;ParameterizedType类型：&quot; + type);</span><br><span class="line">ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">Type[] actualTypeArguments = parameterizedType</span><br><span class="line">.getActualTypeArguments();</span><br><span class="line">System.out.println(&quot;实际参数为：&quot;</span><br><span class="line">+ Arrays.toString(actualTypeArguments));</span><br><span class="line">for (Type actualType : actualTypeArguments) &#123;</span><br><span class="line">if (actualType instanceof WildcardType) &#123;</span><br><span class="line">WildcardType wildcardType = (WildcardType) actualTypeArguments[0];</span><br><span class="line">System.out.println(&quot;实际参数为WildcardType类型：&quot;</span><br><span class="line">+ wildcardType.getUpperBounds());</span><br><span class="line">&#125; else if (actualType instanceof Class) &#123;</span><br><span class="line">System.out.println(&quot;实际参数为Class类型：&quot; + actualType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125; else if (type instanceof GenericArrayType) &#123; // 泛型数组类型 T[]</span><br><span class="line">GenericArrayType genericArrayType = (GenericArrayType) type;</span><br><span class="line">System.out.println(&quot;GenericArrayType类型：&quot;</span><br><span class="line">+ genericArrayType.getGenericComponentType());//T</span><br><span class="line">&#125; else if (type instanceof TypeVariable) &#123; // 泛型变量</span><br><span class="line">System.out.println(&quot;TypeVariable类型：&quot; + type);</span><br><span class="line">&#125; else if (type instanceof Class) &#123; //</span><br><span class="line">System.out.println(&quot;Class类型：&quot; + type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 方法有2个参数，第一个参数list为ParameterizedType，实际参数为T，</span><br><span class="line"> * 第二个参数为GenericArrayType泛型数组类型T[],数组元素类型为T</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//方法参数——注解   第一个参数使用了注解</span><br><span class="line">Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">Annotation myAnnotation=parameterAnnotations[0][0];</span><br><span class="line">//打印 @reflect.MyAnnotation(intValue=0)</span><br><span class="line"></span><br><span class="line">// 7、方法抛出的异常</span><br><span class="line">Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();</span><br><span class="line">// 打印 [class java.lang.RuntimeException, class java.lang.Exception]</span><br><span class="line">Type[] genericExceptionTypes = method.getGenericExceptionTypes();</span><br><span class="line">// 打印 [class java.lang.RuntimeException, class java.lang.Exception]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象,如果参数为基本类型数据,必须转换为相应的包装类型的对象。invoke()方法的返回值总是对象,如果实际被调用的方法的返回类型是基本类型数据,那么invoke()方法会把它转换为相应的包装类型的对象,再将其返回.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2019/05/18/%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/05/18/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="概念">概念<a href="post/反射#概念"></a></h1><p>反射就是把java的各种成分映射成相应的java类</p><p>Class类的构建方法是private，由jvm创建</p><blockquote><p>反射是java语言的一个特性，它允程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个java的类获取他所有的成员变量和方法并且显示出来。</p></blockquote><blockquote><p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p></blockquote><blockquote><p>基本的 Java类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。</p></blockquote><p>在没有对象实例的时候，主要有两种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz1 = Role.class;</span><br><span class="line">Class clazz2 = Class.forName(&quot;yu.Role&quot;);</span><br><span class="line"></span><br><span class="line">Object o = cls1.newInstance();</span><br></pre></td></tr></table></figure></p><blockquote><p>在第二种方法中，forName中的参数一定是完整的类名（包名+类名），并且这个方法需要捕获异常。现在得到cls1就可以创建一个Role类的实例了，利用Class的newInstance方法相当于调用类的默认的构造器。</p></blockquote><h1 id="常用方法">常用方法<a href="post/反射#常用方法"></a></h1><ul><li>getConstructor(Class&lt;?&gt;… parameterTypes)</li></ul><p>返回Constructor反映此Class 对象所表示的类的指定公共构造函数的对象。</p><ul><li>getConstructors()</li></ul><p>返回一个数组，其中包含Constructor反映此Class对象所表示的类的所有公共构造函数的 对象。</p><ul><li>getDeclaredFields()</li></ul><p>返回一个Field对象数组，反映由此Class对象表示的类或接口声明的所有字段 。</p><ul><li>getDeclaredField(String name)</li></ul><p>返回一个Field对象，该对象反映此Class 对象表示的类或接口的指定声明字段。</p><ul><li>getDeclaredMethods()</li></ul><p>返回一个数组，其中包含Method反映此Class对象所表示的类或接口的所有声明方法的对象，包括public，protected，default（包）访问和私有方法，但不包括继承的方法。</p><ul><li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</li></ul><p>返回一个Method对象，该对象反映此Class对象表示的类或接口的指定声明方法 。</p><ul><li>getName()</li></ul><p>返回此Class对象表示的实体名称（类，接口，数组类，基本类型或void），如String。</p><ul><li>isPrimitive()</li></ul><p>确定指定的Class对象是否表示基本类型。</p><h1 id="例题">例题<a href="post/反射#例题"></a></h1><ul><li>将所有String类型的成员变量里的b改成a。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">public class TestReflect &#123;</span><br><span class="line">    public static void main(String[] args) throws SecurityException, NoSuchMethodException, NoSuchFieldException, IllegalArgumentException, Exception &#123;</span><br><span class="line">        ReflectPointer rp1 = new ReflectPointer(3,4);</span><br><span class="line">        changeBtoA(rp1);</span><br><span class="line">        System.out.println(rp1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void changeBtoA(Object obj) throws RuntimeException, Exception &#123;</span><br><span class="line">        Field[] fields = obj.getClass().getFields();</span><br><span class="line"></span><br><span class="line">        for(Field field : fields) &#123;</span><br><span class="line">            //if(field.getType().equals(String.class))</span><br><span class="line">            //由于字节码只有一份,用equals语义不准确</span><br><span class="line">            if(field.getType()==String.class) &#123;</span><br><span class="line">                String oldValue = (String)field.get(obj);</span><br><span class="line">                String newValue = oldValue.replace(&apos;b&apos;, &apos;a&apos;);</span><br><span class="line">                field.set(obj,newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ReflectPointer &#123;</span><br><span class="line"></span><br><span class="line">    private int x = 0;</span><br><span class="line">    public int y = 0;</span><br><span class="line">    public String str1 = &quot;ball&quot;;</span><br><span class="line">    public String str2 = &quot;basketball&quot;;</span><br><span class="line"></span><br><span class="line">    public ReflectPointer(int x,int y) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ReflectPointer [str1=&quot; + str1 + &quot;, str2=&quot; + str2 + &quot;, str3=&quot;</span><br><span class="line">                + str3 + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> reflection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rocketmq-console搭建</title>
      <link href="/2019/05/14/rocketmq-console/"/>
      <url>/2019/05/14/rocketmq-console/</url>
      
        <content type="html"><![CDATA[<h1 id="源码">源码<a href="post/rocketmq-console#源码"></a></h1><ul><li>rocketmq的开源拓展项目<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">rocketmq-externals</a></li><li>选择子模块<a href="https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console" target="_blank" rel="noopener">rocketmq-console</a></li></ul><h1 id="修改配置">修改配置<a href="post/rocketmq-console#修改配置"></a></h1><ul><li>配置文件路径：rocketmq-console/src/main/resources/application.properties</li><li>URL<ul><li>rocketmq.config.namesrvAddr=mq的ip:port</li></ul></li><li>项目启动端口<ul><li>server.port=8080</li></ul></li><li>如果提示10909链接失败<ul><li>rocketmq.config.isVIPChannel=修改为false</li></ul></li><li>eg：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server.contextPath=</span><br><span class="line">#服务运行端口</span><br><span class="line">server.port=8080</span><br><span class="line"></span><br><span class="line">### SSL setting</span><br><span class="line">#server.ssl.key-store=classpath:rmqcngkeystore.jks</span><br><span class="line">#server.ssl.key-store-password=rocketmq</span><br><span class="line">#server.ssl.keyStoreType=PKCS12</span><br><span class="line">#server.ssl.keyAlias=rmqcngkey</span><br><span class="line"></span><br><span class="line">#spring.application.index=true</span><br><span class="line">spring.application.name=rocketmq-console</span><br><span class="line">spring.http.encoding.charset=UTF-8</span><br><span class="line">spring.http.encoding.enabled=true</span><br><span class="line">spring.http.encoding.force=true</span><br><span class="line">logging.config=classpath:logback.xml</span><br><span class="line">#if this value is empty,use env value rocketmq.config.namesrvAddr  NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876</span><br><span class="line">#监听mq服务地址，多个用逗号隔开</span><br><span class="line">rocketmq.config.namesrvAddr=localhost:9876</span><br><span class="line">#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default true</span><br><span class="line">rocketmq.config.isVIPChannel=</span><br><span class="line">#rocketmq-console&apos;s data path:dashboard/monitor</span><br><span class="line">rocketmq.config.dataPath=/tmp/rocketmq-console/data</span><br><span class="line">#set it false if you don&apos;t want use dashboard.default true</span><br><span class="line">rocketmq.config.enableDashBoardCollect=true</span><br><span class="line">#set the message track trace topic if you don&apos;t want use the default one</span><br><span class="line">rocketmq.config.msgTrackTopicName=</span><br><span class="line">rocketmq.config.ticketKey=ticket</span><br><span class="line"></span><br><span class="line">#Must create userInfo file: $&#123;rocketmq.config.dataPath&#125;/users.properties if the login is required</span><br><span class="line">rocketmq.config.loginRequired=false</span><br></pre></td></tr></table></figure></li></ul><h1 id="编译打包">编译打包<a href="post/rocketmq-console#编译打包"></a></h1><p><code>mvn clean package -Dmaven.test.skip=true</code></p><h1 id="运行">运行<a href="post/rocketmq-console#运行"></a></h1><p><code>java -jar rocketmq-console-ng-1.0.1.jar</code></p><h1 id="访问地址">访问地址<a href="post/rocketmq-console#访问地址"></a></h1><p>监控主页：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p>]]></content>
      
      
      <categories>
          
          <category> rocketmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> rocketmq-console </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2019/05/09/shell/"/>
      <url>/2019/05/09/shell/</url>
      
        <content type="html"><![CDATA[<h1 id="基本命令">基本命令<a href="post/shell#基本命令"></a></h1><ul><li><p>列出文件 ls 参数 目录名<br>  例: 看看驱动目录下有什么:ls /System/Library/Extensions<br>  参数 -w 显示中文，-l 详细信息， -a 包括隐藏文件</p></li><li><p>转换目录 cd<br>  例：想到驱动目录下溜达一圈   cd /System/Library/Extensions</p></li><li><p>建立新目录 mkdir 目录名<br>  例：在驱动目录下建一个备份目录backup     mkdir /System/Library/Extensions/   backup</p></li><li><p>拷贝文件 cp 参数 源文件 目标文件<br>  例：想把桌面的Natit.kext 拷贝到驱动目录中  cp -R /User/用户名/Desktop/Natit.kext /System/Library/Extensions 参数R表示对目录进行递归操作</p></li><li><p>删除文件 rm 参数 文件<br>  例：想删除驱动的缓存  rm -rf /System/Library/Extensions.kextcache<br>  参数－rf 表示递归和强制，千万要小心使用，如果执行了 rm -rf / 你的系统就全没了</p></li><li><p>移动文件 mv 文件<br>  例：想把AppleHDA.Kext 移到桌面    mv /System/Library/Extensions/AppleHDA.kext /User/用户名/Desktop</p></li><li><p>文本编辑 nano 文件名<br>  例：编辑natit Info.plist     nano /System/Library/Extensions/Natit.kext/Info.plist</p></li></ul><h1 id="目录操作">目录操作<a href="post/shell#目录操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>mkdir</td><td style="text-align:center">创建一个目录</td><td style="text-align:right">mkdir dirname</td></tr><tr><td>rmdir</td><td style="text-align:center">删除一个目录</td><td style="text-align:right">rmdir dirname</td></tr><tr><td>mvdir</td><td style="text-align:center">移动或重命名一个目录</td><td style="text-align:right">mvdir dir1 dir2</td></tr><tr><td>cd</td><td style="text-align:center">改变当前目录</td><td style="text-align:right">cd dirname</td></tr><tr><td>pwd</td><td style="text-align:center">显示当前目录的路径名</td><td style="text-align:right">pwd</td></tr><tr><td>ls</td><td style="text-align:center">显示当前目录的内容</td><td style="text-align:right">ls -la</td></tr></tbody></table></div></div><h1 id="文件操作">文件操作<a href="post/shell#文件操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>cat</td><td style="text-align:center">显示或连接文件</td><td style="text-align:right">cat filename</td></tr><tr><td>od</td><td style="text-align:center">显示非文本文件的内容</td><td style="text-align:right">od -c filename</td></tr><tr><td>cp</td><td style="text-align:center">复制文件或目录</td><td style="text-align:right">cp file1 file2</td></tr><tr><td>rm</td><td style="text-align:center">删除文件或目录</td><td style="text-align:right">rm filename</td></tr><tr><td>mv</td><td style="text-align:center">改变文件名或所在目录</td><td style="text-align:right">mv file1 file2</td></tr><tr><td>find</td><td style="text-align:center">使用匹配表达式查找文件</td><td style="text-align:right">find . -name “*.c” -print</td></tr><tr><td>file</td><td style="text-align:center">显示文件类型</td><td style="text-align:right">file filename</td></tr></tbody></table></div></div><h1 id="选择操作">选择操作<a href="post/shell#选择操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>head</td><td style="text-align:center">显示文件的最初几行</td><td style="text-align:right">head -20 filename</td></tr><tr><td>tail</td><td style="text-align:center">显示文件的最后几行</td><td style="text-align:right">tail -15 filename</td></tr><tr><td>cut</td><td style="text-align:center">显示文件每行中的某些域</td><td style="text-align:right">cut -f1,7 -d: /etc/passwd</td></tr><tr><td>colrm</td><td style="text-align:center">从标准输入中删除若干列</td><td style="text-align:right">colrm 8 20 file2</td></tr><tr><td>diff</td><td style="text-align:center">比较并显示两个文件的差异</td><td style="text-align:right">diff file1 file2</td></tr><tr><td>sort</td><td style="text-align:center">排序或归并文件</td><td style="text-align:right">sort -d -f -u file1</td></tr><tr><td>uniq</td><td style="text-align:center">去掉文件中的重复行</td><td style="text-align:right">uniq file1 file2</td></tr><tr><td>comm</td><td style="text-align:center">显示两有序文件的公共和非公共行</td><td style="text-align:right">comm file1 file2</td></tr><tr><td>wc</td><td style="text-align:center">统计文件的字符数、词数和行数</td><td style="text-align:right">wc filename</td></tr><tr><td>nl</td><td style="text-align:center">给文件加上行号</td><td style="text-align:right">nl file1 &gt;file2</td></tr></tbody></table></div></div><h1 id="进程操作">进程操作<a href="post/shell#进程操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>ps</td><td style="text-align:center">显示进程当前状态</td><td style="text-align:right">ps u</td></tr><tr><td>kill</td><td style="text-align:center">终止进程</td><td style="text-align:right">kill -9 30142</td></tr></tbody></table></div></div><h1 id="时间操作">时间操作<a href="post/shell#时间操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>date</td><td style="text-align:center">显示系统的当前日期和时间</td><td style="text-align:right">date</td></tr><tr><td>cal</td><td style="text-align:center">显示日历</td><td style="text-align:right">cal 8 1996</td></tr><tr><td>time</td><td style="text-align:center">统计程序的执行时间</td><td style="text-align:right">time a.out</td></tr></tbody></table></div></div><h1 id="网络与通信操作">网络与通信操作<a href="post/shell#网络与通信操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>telnet</td><td style="text-align:center">远程登录</td><td style="text-align:right">telnet hpc.sp.net.edu.cn</td></tr><tr><td>rlogin</td><td style="text-align:center">远程登录</td><td style="text-align:right">rlogin hostname -l username</td></tr><tr><td>rsh</td><td style="text-align:center">在远程主机执行指定命令</td><td style="text-align:right">rsh f01n03 date</td></tr><tr><td>ftp</td><td style="text-align:center">在本地主机与远程主机之间传输文件</td><td style="text-align:right">ftp ftp.sp.net.edu.cn</td></tr><tr><td>rcp</td><td style="text-align:center">在本地主机与远程主机之间复制文件</td><td style="text-align:right">rcp file1 host1:file2</td></tr><tr><td>ping</td><td style="text-align:center">给一个网络主机发送 回应请求</td><td style="text-align:right">ping hpc.sp.net.edu.cn</td></tr><tr><td>mail</td><td style="text-align:center">阅读和发送电子邮件</td><td style="text-align:right">mail</td></tr><tr><td>write</td><td style="text-align:center">给另一用户发送报文</td><td style="text-align:right">write username pts/1</td></tr><tr><td>mesg</td><td style="text-align:center">允许或拒绝接收报文</td><td style="text-align:right">mesg n</td></tr></tbody></table></div></div><h1 id="Korn-Shell-命令">Korn Shell 命令<a href="post/shell#Korn-Shell-命令"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>history</td><td style="text-align:center">列出最近执行过的几条命令及编号</td><td style="text-align:right">history</td></tr><tr><td>r</td><td style="text-align:center">重复执行最近执行过的某条命令</td><td style="text-align:right">r -2</td></tr><tr><td>alias</td><td style="text-align:center">给某个命令定义别名</td><td style="text-align:right">alias del=rm -i</td></tr><tr><td>unalias</td><td style="text-align:center">取消对某个别名的定义</td><td style="text-align:right">unalias del</td></tr></tbody></table></div></div><h1 id="其它命令">其它命令<a href="post/shell#其它命令"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>uname</td><td style="text-align:center">显示操作系统的有关信息</td><td style="text-align:right">uname -a</td></tr><tr><td>clear</td><td style="text-align:center">清除屏幕或窗口内容</td><td style="text-align:right">clear</td></tr><tr><td>env</td><td style="text-align:center">显示当前所有设置过的环境变量</td><td style="text-align:right">env</td></tr><tr><td>who</td><td style="text-align:center">列出当前登录的所有用户</td><td style="text-align:right">who</td></tr><tr><td>whoami</td><td style="text-align:center">显示当前正进行操作的用户名</td><td style="text-align:right">whoami</td></tr><tr><td>tty</td><td style="text-align:center">显示终端或伪终端的名称</td><td style="text-align:right">tty</td></tr><tr><td>stty</td><td style="text-align:center">显示或重置控制键定义</td><td style="text-align:right">stty -a</td></tr><tr><td>du</td><td style="text-align:center">查询磁盘使用情况</td><td style="text-align:right">du -k subdir</td></tr><tr><td>df</td><td style="text-align:center">显示文件系统的总空间和可用空间</td><td style="text-align:right">df /tmp</td></tr><tr><td>w</td><td style="text-align:center">显示当前系统活动的总信息</td><td style="text-align:right">w</td></tr></tbody></table></div></div>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2019/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式">适配器模式<a href="post/设计模式#适配器模式"></a></h2><h3 id="有两个编译好的无源码的类，类a需要一个特定的功能才能可用。这个功能需要实现接口a。但是类b恰好有这个功能，但是实现的是接口b，这时需要写一个适配器。">有两个编译好的无源码的类，类a需要一个特定的功能才能可用。这个功能需要实现接口a。但是类b恰好有这个功能，但是实现的是接口b，这时需要写一个适配器。<a href="post/设计模式#有两个编译好的无源码的类，类a需要一个特定的功能才能可用。这个功能需要实现接口a。但是类b恰好有这个功能，但是实现的是接口b，这时需要写一个适配器。"></a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface XmlReader&#123;</span><br><span class="line">    public InputStream xmlReader();</span><br><span class="line">&#125;</span><br><span class="line">public interface ReaderXml&#123;</span><br><span class="line">    public InputStream readerXml();</span><br><span class="line">&#125;</span><br><span class="line">public class Adapter implements XmlReader extends B&#123;</span><br><span class="line">    public InputStream xmlReader()&#123;</span><br><span class="line">        return readerXml();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式所涉及的角色">适配器模式所涉及的角色<a href="post/设计模式#适配器模式所涉及的角色"></a></h3><ul><li>目标（CTarget）</li></ul><h4 id="定义一个客户端使用的特定接口">定义一个客户端使用的特定接口<a href="post/设计模式#定义一个客户端使用的特定接口"></a></h4><ul><li>客户（CClient）</li></ul><h4 id="使用目标接口，与目标接口一致的对象合作">使用目标接口，与目标接口一致的对象合作<a href="post/设计模式#使用目标接口，与目标接口一致的对象合作"></a></h4><ul><li>被适配者（CAdaptee）</li></ul><h4 id="一个现存需要匹配的接口">一个现存需要匹配的接口<a href="post/设计模式#一个现存需要匹配的接口"></a></h4><ul><li>适配器（CAdapter）</li></ul><h4 id="负责将CAdaptee接口转成CTarget接口">负责将CAdaptee接口转成CTarget接口<a href="post/设计模式#负责将CAdaptee接口转成CTarget接口"></a></h4><h3 id="适配器分为对象适配器和类适配器">适配器分为对象适配器和类适配器<a href="post/设计模式#适配器分为对象适配器和类适配器"></a></h3><ul><li>对象适配器包含一个适配器者的引用</li><li>类适配器：适配器内部调用他所继承的适配者的方法</li></ul><h3 id="EG">EG<a href="post/设计模式#EG"></a></h3><ul><li>电脑接口</li><li>插座</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adapter Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/05/05/hello-world/"/>
      <url>/2019/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start">Quick Start<a href="post/hello-world#Quick-Start"></a></h2><h3 id="Create-a-new-post">Create a new post<a href="post/hello-world#Create-a-new-post"></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server">Run server<a href="post/hello-world#Run-server"></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files">Generate static files<a href="post/hello-world#Generate-static-files"></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites<a href="post/hello-world#Deploy-to-remote-sites"></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
