<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java8新特性lambda表达式、方法引用、函数式接口、默认方式、静态方法</title>
      <link href="/2019/05/20/java8%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/05/20/java8%E9%83%A8%E5%88%86%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="lambda-表达式">lambda 表达式<a href="post/java8部分新特性#lambda-表达式"></a></h1><h2 id="线程的用法">线程的用法<a href="post/java8部分新特性#线程的用法"></a></h2><p>原始的线程用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//使用匿名内部类的方式启动多线程</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;这是使用匿名内部类的方式。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>lambda表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用lambda表达式方式</span><br><span class="line">new Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;这是使用lambda表达式的方式。。。&quot;);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><h2 id="遍历方式">遍历方式<a href="post/java8部分新特性#遍历方式"></a></h2><p>原始方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//原始方式</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">for (int i : list) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambda表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用lambda表达式代替foreach循环</span><br><span class="line">Stream.of(1, 2, 3, 4, 5).forEach((x) -&gt; &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">([参数可选，...]) -&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法引用">方法引用<a href="post/java8部分新特性#方法引用"></a></h1><p>方法引用其实是 lambda 表达式的部分的简化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_method_reference() &#123;</span><br><span class="line">    //使用lambda表达式</span><br><span class="line">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class="line">        .map(s -&gt; s.length()) //lambda</span><br><span class="line">        .forEach((x) -&gt; &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    //使用静态方法引用</span><br><span class="line">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class="line">        .map(String::length) //静态方法引用</span><br><span class="line">        .forEach((x) -&gt; &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    //使用实例方法引用</span><br><span class="line">    Stream.of(</span><br><span class="line">        new ClassMate(&quot;1&quot;, &quot;欧阳思海&quot;),</span><br><span class="line">        new ClassMate(&quot;2&quot;, &quot;sihai&quot;)</span><br><span class="line">    ).map(ClassMate::getName)//实例方法引用</span><br><span class="line">        .forEach(x -&gt; &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>第一个使用lambda表达式获取每个字符串的长度s -&gt; s.length()<br>第二个使用静态方法获取每个字符串的长度String::length<br>第三个使用实例方法引用ClassMate::getName</p></blockquote><p>解释</p><ul><li>map方法是映射的意思</li><li>forEach方法是遍历每一个元素</li></ul><p>总结</p><blockquote><p>使用方法 类名::方法</p></blockquote><blockquote><p>方法可以是静态方法和实例方法</p></blockquote><h1 id="构造函数引用">构造函数引用<a href="post/java8部分新特性#构造函数引用"></a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test_method_reference2() &#123;</span><br><span class="line">    //使用lambda表达式</span><br><span class="line">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class="line">        .map(s -&gt; new ClassMate(s)) //lambda</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    //使用构造函数引用</span><br><span class="line">    Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;)</span><br><span class="line">        .map(ClassMate::new) //构造函数引用,由上下文决定用哪一个构造函数</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一个我们使用的是 lambda 表达式进行创建对象的 s -&gt; new ClassMate(s)。</p></blockquote><blockquote><p>第二个我们使用的是构造函数引用创建对象的 ClassMate::new 。</p></blockquote><blockquote><p>我们发现构造函数引用：类名::new ，然后对于使用哪一个构造函数是由上下文决定的，比如有一个参数和两个参数和无参数的构造函数，会自动确定用哪一个。</p></blockquote><h1 id="接口">接口<a href="post/java8部分新特性#接口"></a></h1><p>在 Java 8 之前的接口是不能有实现的，只能定义抽象方法，然而，在 Java 8 以后，增加了一个新的功能，可以添加实现，可以定义默认方法，可以定义静态方法。</p><h2 id="函数式接口">函数式接口<a href="post/java8部分新特性#函数式接口"></a></h2><p>在一个接口中我们以 @FunctionalInterface 注解声明一个接口，并且接口中只有一个抽象方法，那么我们就叫做这是一个函数式接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalInterfaceTest &#123;</span><br><span class="line">    //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口</span><br><span class="line">    void test(String s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="默认方法">默认方法<a href="post/java8部分新特性#默认方法"></a></h2><p>默认方法很简单，用 default 声明即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalInterfaceTest &#123;</span><br><span class="line">    //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口</span><br><span class="line">    void test(String s);</span><br><span class="line"></span><br><span class="line">    //默认方法</span><br><span class="line">    default String getStr()&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态方法">静态方法<a href="post/java8部分新特性#静态方法"></a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface FunctionalInterfaceTest &#123;</span><br><span class="line">    //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口</span><br><span class="line">    void test(String s);</span><br><span class="line"></span><br><span class="line">    //静态方法</span><br><span class="line">    static String getStr()&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //错误用法</span><br><span class="line">    default static String getStr3()&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现的静态方法，用 static 声明。</p></blockquote><blockquote><p>注意不能同时使用 default 和 static 声明。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Method类</title>
      <link href="/2019/05/18/Method/"/>
      <url>/2019/05/18/Method/</url>
      
        <content type="html"><![CDATA[<p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。</p><p>一个完整方法包含的属性有：</p><ul><li>方法上使用的注解</li><li>方法的修饰符</li><li>方法上定义的泛型参数</li><li>方法的返回值</li><li>方法名称</li><li>方法参数(泛型、注解)</li><li>方法抛出的异常</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotation</span><br><span class="line">public &lt;T&gt; boolean add(List&lt;T&gt; list,T...params)throws RuntimeException,Exception&#123;</span><br><span class="line">if(null==list)&#123;</span><br><span class="line">throw new RuntimeException(&quot;list=null&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(null==params)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">//将参数添加到List集合中</span><br><span class="line">if(null!=params)&#123;</span><br><span class="line">for(T t:params)&#123;</span><br><span class="line">list.add(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解：@MyAnnotation</p><p>修饰符：public</p><p>泛型参数：T</p><p>返回值：boolean</p><p>方法名：add</p><p>方法参数(泛型、注解)：List<t> list，T…params</t></p><p>抛出的异常：RuntimeException，Exception</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MethodTest &#123;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 一个完整方法包含的属性有： 方法上使用的注解、方法的修饰符、方法上定义的泛型参数、方法的返回值、方法名称、方法参数(泛型、注解)、方法抛出的异常</span><br><span class="line"> */</span><br><span class="line">@MyAnnotation</span><br><span class="line">private &lt;T&gt; boolean add(@MyAnnotation List&lt;T&gt; list, T... params) throws RuntimeException,</span><br><span class="line">Exception &#123;</span><br><span class="line">if (null == list) &#123;</span><br><span class="line">throw new RuntimeException(&quot;list=null&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">if (null == params) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">// 将参数添加到List集合中</span><br><span class="line">if (null != params) &#123;</span><br><span class="line">for (T t : params) &#123;</span><br><span class="line">list.add(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">// 获取Method</span><br><span class="line">MethodTest obj = new MethodTest();</span><br><span class="line">Class&lt;? extends MethodTest&gt; clazz = obj.getClass();</span><br><span class="line"> </span><br><span class="line">Method method = clazz.getDeclaredMethod(&quot;add&quot;, List.class,</span><br><span class="line">Object[].class);</span><br><span class="line">if (!method.isAccessible()) &#123;</span><br><span class="line">method.setAccessible(true);</span><br><span class="line">&#125;</span><br><span class="line">        //获取方法基本信息</span><br><span class="line">getMethodInfo(method);</span><br><span class="line"></span><br><span class="line">// 调用方法</span><br><span class="line">List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();</span><br><span class="line">method.invoke(obj, arrayList, new String[] &#123; &quot;1&quot;, &quot;2&quot; &#125;);</span><br><span class="line">System.out.println(arrayList);//[1,2]</span><br><span class="line"></span><br><span class="line">//方法定义所在的类</span><br><span class="line">Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line"></span><br><span class="line">// 如果此方法是 bridge 方法，则返回 true；</span><br><span class="line">boolean bridge = method.isBridge();</span><br><span class="line">//如果该方法是public非抽象非静态，且定义在接口中，则返回true</span><br><span class="line">boolean default1 = method.isDefault(); //false</span><br><span class="line">//如果此方法为复合方法，则返回 true；</span><br><span class="line">boolean synthetic = method.isSynthetic();//false</span><br><span class="line">// 如果将此方法的参数带有可变参数，则返回 true</span><br><span class="line">boolean varArgs = method.isVarArgs(); //true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private static void getMethodInfo(Method method) &#123;</span><br><span class="line">// 1、获取方法上的注解</span><br><span class="line">boolean annotationPresent = method</span><br><span class="line">.isAnnotationPresent(MyAnnotation.class);</span><br><span class="line">if (annotationPresent) &#123;</span><br><span class="line">MyAnnotation myAnnotation = method</span><br><span class="line">.getDeclaredAnnotation(MyAnnotation.class);</span><br><span class="line">&#125;</span><br><span class="line">// 2、方法的修饰符</span><br><span class="line">int modifiers = method.getModifiers();</span><br><span class="line">String modify = Modifier.toString(modifiers);// private</span><br><span class="line">// 3、方法上定义的泛型参数</span><br><span class="line">TypeVariable&lt;Method&gt;[] typeParameters = method.getTypeParameters();// [T]</span><br><span class="line">// 4、方法的返回值</span><br><span class="line">Class&lt;?&gt; returnType = method.getReturnType();// boolean</span><br><span class="line">Type genericReturnType = method.getGenericReturnType();// boolean</span><br><span class="line">// 5、方法名称</span><br><span class="line">String name = method.getName();</span><br><span class="line">// 6、方法参数</span><br><span class="line">int parameterCount = method.getParameterCount();// 参数个数 2</span><br><span class="line">// 方法参数——泛型</span><br><span class="line">Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">// 打印 [interface java.util.List, class [Ljava.lang.Object;]</span><br><span class="line">Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">// 打印 [java.util.List&lt;T&gt;, T[]]</span><br><span class="line">for (Type type : genericParameterTypes) &#123;</span><br><span class="line">if (type instanceof ParameterizedType) &#123; // 参数类型</span><br><span class="line">System.out.println(&quot;ParameterizedType类型：&quot; + type);</span><br><span class="line">ParameterizedType parameterizedType = (ParameterizedType) type;</span><br><span class="line">Type[] actualTypeArguments = parameterizedType</span><br><span class="line">.getActualTypeArguments();</span><br><span class="line">System.out.println(&quot;实际参数为：&quot;</span><br><span class="line">+ Arrays.toString(actualTypeArguments));</span><br><span class="line">for (Type actualType : actualTypeArguments) &#123;</span><br><span class="line">if (actualType instanceof WildcardType) &#123;</span><br><span class="line">WildcardType wildcardType = (WildcardType) actualTypeArguments[0];</span><br><span class="line">System.out.println(&quot;实际参数为WildcardType类型：&quot;</span><br><span class="line">+ wildcardType.getUpperBounds());</span><br><span class="line">&#125; else if (actualType instanceof Class) &#123;</span><br><span class="line">System.out.println(&quot;实际参数为Class类型：&quot; + actualType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125; else if (type instanceof GenericArrayType) &#123; // 泛型数组类型 T[]</span><br><span class="line">GenericArrayType genericArrayType = (GenericArrayType) type;</span><br><span class="line">System.out.println(&quot;GenericArrayType类型：&quot;</span><br><span class="line">+ genericArrayType.getGenericComponentType());//T</span><br><span class="line">&#125; else if (type instanceof TypeVariable) &#123; // 泛型变量</span><br><span class="line">System.out.println(&quot;TypeVariable类型：&quot; + type);</span><br><span class="line">&#125; else if (type instanceof Class) &#123; //</span><br><span class="line">System.out.println(&quot;Class类型：&quot; + type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 方法有2个参数，第一个参数list为ParameterizedType，实际参数为T，</span><br><span class="line"> * 第二个参数为GenericArrayType泛型数组类型T[],数组元素类型为T</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//方法参数——注解   第一个参数使用了注解</span><br><span class="line">Annotation[][] parameterAnnotations = method.getParameterAnnotations();</span><br><span class="line">Annotation myAnnotation=parameterAnnotations[0][0];</span><br><span class="line">//打印 @reflect.MyAnnotation(intValue=0)</span><br><span class="line"></span><br><span class="line">// 7、方法抛出的异常</span><br><span class="line">Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();</span><br><span class="line">// 打印 [class java.lang.RuntimeException, class java.lang.Exception]</span><br><span class="line">Type[] genericExceptionTypes = method.getGenericExceptionTypes();</span><br><span class="line">// 打印 [class java.lang.RuntimeException, class java.lang.Exception]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象,如果参数为基本类型数据,必须转换为相应的包装类型的对象。invoke()方法的返回值总是对象,如果实际被调用的方法的返回类型是基本类型数据,那么invoke()方法会把它转换为相应的包装类型的对象,再将其返回.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Method </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2019/05/18/%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/05/18/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="概念">概念<a href="post/反射#概念"></a></h1><p>反射就是把java的各种成分映射成相应的java类</p><p>Class类的构建方法是private，由jvm创建</p><blockquote><p>反射是java语言的一个特性，它允程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个java的类获取他所有的成员变量和方法并且显示出来。</p></blockquote><blockquote><p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。</p></blockquote><blockquote><p>基本的 Java类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。</p></blockquote><p>在没有对象实例的时候，主要有两种方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class clazz1 = Role.class;</span><br><span class="line">Class clazz2 = Class.forName(&quot;yu.Role&quot;);</span><br><span class="line"></span><br><span class="line">Object o = cls1.newInstance();</span><br></pre></td></tr></table></figure></p><blockquote><p>在第二种方法中，forName中的参数一定是完整的类名（包名+类名），并且这个方法需要捕获异常。现在得到cls1就可以创建一个Role类的实例了，利用Class的newInstance方法相当于调用类的默认的构造器。</p></blockquote><h1 id="常用方法">常用方法<a href="post/反射#常用方法"></a></h1><ul><li>getConstructor(Class&lt;?&gt;… parameterTypes)</li></ul><p>返回Constructor反映此Class 对象所表示的类的指定公共构造函数的对象。</p><ul><li>getConstructors()</li></ul><p>返回一个数组，其中包含Constructor反映此Class对象所表示的类的所有公共构造函数的 对象。</p><ul><li>getDeclaredFields()</li></ul><p>返回一个Field对象数组，反映由此Class对象表示的类或接口声明的所有字段 。</p><ul><li>getDeclaredField(String name)</li></ul><p>返回一个Field对象，该对象反映此Class 对象表示的类或接口的指定声明字段。</p><ul><li>getDeclaredMethods()</li></ul><p>返回一个数组，其中包含Method反映此Class对象所表示的类或接口的所有声明方法的对象，包括public，protected，default（包）访问和私有方法，但不包括继承的方法。</p><ul><li>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</li></ul><p>返回一个Method对象，该对象反映此Class对象表示的类或接口的指定声明方法 。</p><ul><li>getName()</li></ul><p>返回此Class对象表示的实体名称（类，接口，数组类，基本类型或void），如String。</p><ul><li>isPrimitive()</li></ul><p>确定指定的Class对象是否表示基本类型。</p><h1 id="例题">例题<a href="post/反射#例题"></a></h1><ul><li>将所有String类型的成员变量里的b改成a。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">public class TestReflect &#123;</span><br><span class="line">    public static void main(String[] args) throws SecurityException, NoSuchMethodException, NoSuchFieldException, IllegalArgumentException, Exception &#123;</span><br><span class="line">        ReflectPointer rp1 = new ReflectPointer(3,4);</span><br><span class="line">        changeBtoA(rp1);</span><br><span class="line">        System.out.println(rp1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void changeBtoA(Object obj) throws RuntimeException, Exception &#123;</span><br><span class="line">        Field[] fields = obj.getClass().getFields();</span><br><span class="line"></span><br><span class="line">        for(Field field : fields) &#123;</span><br><span class="line">            //if(field.getType().equals(String.class))</span><br><span class="line">            //由于字节码只有一份,用equals语义不准确</span><br><span class="line">            if(field.getType()==String.class) &#123;</span><br><span class="line">                String oldValue = (String)field.get(obj);</span><br><span class="line">                String newValue = oldValue.replace(&apos;b&apos;, &apos;a&apos;);</span><br><span class="line">                field.set(obj,newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ReflectPointer &#123;</span><br><span class="line"></span><br><span class="line">    private int x = 0;</span><br><span class="line">    public int y = 0;</span><br><span class="line">    public String str1 = &quot;ball&quot;;</span><br><span class="line">    public String str2 = &quot;basketball&quot;;</span><br><span class="line"></span><br><span class="line">    public ReflectPointer(int x,int y) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;ReflectPointer [str1=&quot; + str1 + &quot;, str2=&quot; + str2 + &quot;, str3=&quot;</span><br><span class="line">                + str3 + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> reflection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Field类</title>
      <link href="/2019/05/18/Field/"/>
      <url>/2019/05/18/Field/</url>
      
        <content type="html"><![CDATA[<p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p><h1 id="Field-成员变量的介绍">Field 成员变量的介绍<a href="post/Field#Field-成员变量的介绍"></a></h1><blockquote><p>每个成员变量有类型和值。java.lang.reflect.Field 为我们提供了获取当前对象的成员变量的类型，和重新设值的方法。</p></blockquote><h1 id="获取变量的类型">获取变量的类型<a href="post/Field#获取变量的类型"></a></h1><p>类中的变量分为两种类型：基本类型和引用类型：</p><ul><li>基本类型（ 8 种） <ul><li>整数：byte, short, int, long</li><li>浮点数：float, double</li><li>字符：char</li><li>布尔值：boolean</li></ul></li><li>引用类型 <ul><li>所有的引用类型都继承自 java.lang.Object</li><li>类，枚举，数组，接口都是引用类型</li><li>java.io.Serializable 接口，基本类型的包装类（比如 java.lang.Double）也是引用类型</li></ul></li></ul><p>java.lang.reflect.Field 提供了两个方法获去变量的类型：</p><blockquote><p>Field.getType()：返回这个变量的类型</p></blockquote><blockquote><p>Field.getGenericType()：如果当前属性有签名属性类型就返回，否则就返回 Field.getType()</p></blockquote><blockquote><p>field.getType()和field.getGenericType()的区别就是返回类型不一样</p></blockquote><h1 id="获取成员变量的修饰符">获取成员变量的修饰符<a href="post/Field#获取成员变量的修饰符"></a></h1><p>成员变量可以被以下修饰符修饰：</p><ul><li>访问权限控制符：public, protected, private</li><li>限制只能有一个实例的：static</li><li>不允许修改的：final</li><li>不会被序列化：transient</li><li>线程共享数据的一致性：volatile</li><li>注解</li></ul><p>类似获取 Class 的修饰符，我们可以使用 Field.getModifiers() 方法获取当前成员变量的修饰符。<br>返回 java.lang.reflect.Modifier 中定义的整形值。然后使用 Modifier.toString(int mod)解码成字符串</p><p>由于 Field 间接继承了 java.lang.reflect.AnnotatedElement ，因此运行时也可以获得修饰成员变量的注解，当然前提是这个注解被 java.lang.annotation.RetentionPolicy.RUNTIME 修饰。</p><h1 id="获取和修改成员变量的值">获取和修改成员变量的值<a href="post/Field#获取和修改成员变量的值"></a></h1><p>拿到一个对象后，我们可以在运行时修改它的成员变量的值，对运行时来说，反射修改变量值的操作和类中修改变量的结果是一样的。</p><ul><li><p>基本类型的getter方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">byte getByte(Object obj) </span><br><span class="line">    获取一个静态或实例 byte 字段的值。 </span><br><span class="line">int getInt(Object obj) </span><br><span class="line">    获取 int 类型或另一个通过扩展转换可以转换为 int 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> short getShort(Object obj) </span><br><span class="line">    获取 short 类型或另一个通过扩展转换可以转换为 short 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> long getLong(Object obj) </span><br><span class="line">    获取 long 类型或另一个通过扩展转换可以转换为 long 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> float getFloat(Object obj) </span><br><span class="line">    获取 float 类型或另一个通过扩展转换可以转换为 float 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> double getDouble(Object obj) </span><br><span class="line">    获取 double 类型或另一个通过扩展转换可以转换为 double 类型的基本类型的静态或实例字段的值。 </span><br><span class="line"> boolean getBoolean(Object obj) </span><br><span class="line">    获取一个静态或实例 boolean 字段的值。 </span><br><span class="line"> char getChar(Object obj) </span><br><span class="line">    获取 char 类型或另一个通过扩展转换可以转换为 char 类型的基本类型的静态或实例字段的值。</span><br></pre></td></tr></table></figure></li><li><p>基本类型的setter</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void setByte(Object obj, byte b) </span><br><span class="line">    将字段的值设置为指定对象上的一个 byte 值。 </span><br><span class="line"> void setShort(Object obj, short s) </span><br><span class="line">    将字段的值设置为指定对象上的一个 short 值。</span><br><span class="line"> void setInt(Object obj, int i) </span><br><span class="line">    将字段的值设置为指定对象上的一个 int 值。 </span><br><span class="line"> void setLong(Object obj, long l) </span><br><span class="line">    将字段的值设置为指定对象上的一个 long 值。 </span><br><span class="line"> void setFloat(Object obj, float f) </span><br><span class="line">    将字段的值设置为指定对象上的一个 float 值。</span><br><span class="line"> void setDouble(Object obj, double d) </span><br><span class="line">    将字段的值设置为指定对象上的一个 double 值。</span><br><span class="line"> void setBoolean(Object obj, boolean z) </span><br><span class="line">    将字段的值设置为指定对象上的一个 boolean 值。 </span><br><span class="line"> void setChar(Object obj, char c) </span><br><span class="line">    将字段的值设置为指定对象上的一个 char 值。</span><br></pre></td></tr></table></figure><ul><li>引用类型的getter</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object get(Object obj) </span><br><span class="line">    返回指定对象上此 Field 表示的字段的值。</span><br></pre></td></tr></table></figure><ul><li>引用类型的setter</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void set(Object obj, Object value) </span><br><span class="line">    将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</span><br></pre></td></tr></table></figure><blockquote><p>再说一下setAccessible()方法，Field的setAccessible()方法是从AccessibleObject类继承而来的。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。<br>它提供了在使用时 取消默认 Java 语言访问控制检查的能力。<br>一般情况下，我们并不能对类的私有字段进行操作，利用反射也不例外，但有的时候，例如要序列化的时候，我们又必须有能力去处理这些字段，这时候，我们就需要调用AccessibleObject上的setAccessible()方法来允许这种访问，而由于反射类中的Field，Method和Constructor继承自AccessibleObject，因此，通过在Field，Method和Constructor这些类上调用setAccessible()方法，我们可以操作这些字段无法访问的字段。</p></blockquote><h1 id="其他方法">其他方法<a href="post/Field#其他方法"></a></h1><ul><li>boolean</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(Object obj) </span><br><span class="line">    将此 Field 与指定对象比较。 </span><br><span class="line">boolean isEnumConstant() </span><br><span class="line">    如果此字段表示枚举类型的元素，则返回 true；否则返回 false。 </span><br><span class="line">boolean isSynthetic() </span><br><span class="line">    如果此字段是复合字段，则返回 true；否则返回 false。</span><br></pre></td></tr></table></figure><ul><li>String</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String getName() </span><br><span class="line">    返回此 Field 对象表示的字段的名称。 </span><br><span class="line">String toGenericString() </span><br><span class="line">    返回一个描述此 Field（包括其一般类型）的字符串。 </span><br><span class="line">String toString() </span><br><span class="line">    返回一个描述此 Field 的字符串。</span><br></pre></td></tr></table></figure><ul><li>其他</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int hashCode()</span><br><span class="line">    返回该 Field 的哈希码。</span><br><span class="line">boolean equals(Object obj)</span><br><span class="line">    将此 Field 与指定对象比较。</span><br></pre></td></tr></table></figure><ul><li><p>equals()和hashCode()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Annotation&gt; T  getAnnotation(Class&lt;T&gt; annotationClass)</span><br><span class="line">    如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。</span><br></pre></td></tr></table></figure></li><li><p>返回注释的方法：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] getDeclaredAnnotations()</span><br><span class="line">    返回直接存在于此元素上的所有注释。</span><br></pre></td></tr></table></figure><ul><li>返回字段所在的类或者接口的Class对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; getDeclaringClass()</span><br><span class="line">    返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段。</span><br></pre></td></tr></table></figure><ul><li>返回字段的类型（Type）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type getGenericType()</span><br><span class="line">    返回一个 Type 对象，它表示此 Field 对象所表示字段的声明类型。</span><br></pre></td></tr></table></figure><ul><li>返回修饰符编码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int getModifiers()</span><br><span class="line">    以整数形式返回由此 Field 对象表示的字段的 Java 语言修饰符。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Field </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rocketmq-console搭建</title>
      <link href="/2019/05/14/rocketmq-console/"/>
      <url>/2019/05/14/rocketmq-console/</url>
      
        <content type="html"><![CDATA[<h1 id="源码">源码<a href="post/rocketmq-console#源码"></a></h1><ul><li>rocketmq的开源拓展项目<a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">rocketmq-externals</a></li><li>选择子模块<a href="https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console" target="_blank" rel="noopener">rocketmq-console</a></li></ul><h1 id="修改配置">修改配置<a href="post/rocketmq-console#修改配置"></a></h1><ul><li>配置文件路径：rocketmq-console/src/main/resources/application.properties</li><li>URL<ul><li>rocketmq.config.namesrvAddr=mq的ip:port</li></ul></li><li>项目启动端口<ul><li>server.port=8080</li></ul></li><li>如果提示10909链接失败<ul><li>rocketmq.config.isVIPChannel=修改为false</li></ul></li><li>eg：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">server.contextPath=</span><br><span class="line">#服务运行端口</span><br><span class="line">server.port=8080</span><br><span class="line"></span><br><span class="line">### SSL setting</span><br><span class="line">#server.ssl.key-store=classpath:rmqcngkeystore.jks</span><br><span class="line">#server.ssl.key-store-password=rocketmq</span><br><span class="line">#server.ssl.keyStoreType=PKCS12</span><br><span class="line">#server.ssl.keyAlias=rmqcngkey</span><br><span class="line"></span><br><span class="line">#spring.application.index=true</span><br><span class="line">spring.application.name=rocketmq-console</span><br><span class="line">spring.http.encoding.charset=UTF-8</span><br><span class="line">spring.http.encoding.enabled=true</span><br><span class="line">spring.http.encoding.force=true</span><br><span class="line">logging.config=classpath:logback.xml</span><br><span class="line">#if this value is empty,use env value rocketmq.config.namesrvAddr  NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876</span><br><span class="line">#监听mq服务地址，多个用逗号隔开</span><br><span class="line">rocketmq.config.namesrvAddr=localhost:9876</span><br><span class="line">#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default true</span><br><span class="line">rocketmq.config.isVIPChannel=</span><br><span class="line">#rocketmq-console&apos;s data path:dashboard/monitor</span><br><span class="line">rocketmq.config.dataPath=/tmp/rocketmq-console/data</span><br><span class="line">#set it false if you don&apos;t want use dashboard.default true</span><br><span class="line">rocketmq.config.enableDashBoardCollect=true</span><br><span class="line">#set the message track trace topic if you don&apos;t want use the default one</span><br><span class="line">rocketmq.config.msgTrackTopicName=</span><br><span class="line">rocketmq.config.ticketKey=ticket</span><br><span class="line"></span><br><span class="line">#Must create userInfo file: $&#123;rocketmq.config.dataPath&#125;/users.properties if the login is required</span><br><span class="line">rocketmq.config.loginRequired=false</span><br></pre></td></tr></table></figure></li></ul><h1 id="编译打包">编译打包<a href="post/rocketmq-console#编译打包"></a></h1><p><code>mvn clean package -Dmaven.test.skip=true</code></p><h1 id="运行">运行<a href="post/rocketmq-console#运行"></a></h1><p><code>java -jar rocketmq-console-ng-1.0.1.jar</code></p><h1 id="访问地址">访问地址<a href="post/rocketmq-console#访问地址"></a></h1><p>监控主页：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p>]]></content>
      
      
      <categories>
          
          <category> rocketmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> rocketmq-console </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2019/05/09/shell/"/>
      <url>/2019/05/09/shell/</url>
      
        <content type="html"><![CDATA[<h1 id="基本命令">基本命令<a href="post/shell#基本命令"></a></h1><ul><li><p>列出文件 ls 参数 目录名<br>  例: 看看驱动目录下有什么:ls /System/Library/Extensions<br>  参数 -w 显示中文，-l 详细信息， -a 包括隐藏文件</p></li><li><p>转换目录 cd<br>  例：想到驱动目录下溜达一圈   cd /System/Library/Extensions</p></li><li><p>建立新目录 mkdir 目录名<br>  例：在驱动目录下建一个备份目录backup     mkdir /System/Library/Extensions/   backup</p></li><li><p>拷贝文件 cp 参数 源文件 目标文件<br>  例：想把桌面的Natit.kext 拷贝到驱动目录中  cp -R /User/用户名/Desktop/Natit.kext /System/Library/Extensions 参数R表示对目录进行递归操作</p></li><li><p>删除文件 rm 参数 文件<br>  例：想删除驱动的缓存  rm -rf /System/Library/Extensions.kextcache<br>  参数－rf 表示递归和强制，千万要小心使用，如果执行了 rm -rf / 你的系统就全没了</p></li><li><p>移动文件 mv 文件<br>  例：想把AppleHDA.Kext 移到桌面    mv /System/Library/Extensions/AppleHDA.kext /User/用户名/Desktop</p></li><li><p>文本编辑 nano 文件名<br>  例：编辑natit Info.plist     nano /System/Library/Extensions/Natit.kext/Info.plist</p></li></ul><h1 id="目录操作">目录操作<a href="post/shell#目录操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>mkdir</td><td style="text-align:center">创建一个目录</td><td style="text-align:right">mkdir dirname</td></tr><tr><td>rmdir</td><td style="text-align:center">删除一个目录</td><td style="text-align:right">rmdir dirname</td></tr><tr><td>mvdir</td><td style="text-align:center">移动或重命名一个目录</td><td style="text-align:right">mvdir dir1 dir2</td></tr><tr><td>cd</td><td style="text-align:center">改变当前目录</td><td style="text-align:right">cd dirname</td></tr><tr><td>pwd</td><td style="text-align:center">显示当前目录的路径名</td><td style="text-align:right">pwd</td></tr><tr><td>ls</td><td style="text-align:center">显示当前目录的内容</td><td style="text-align:right">ls -la</td></tr></tbody></table></div></div><h1 id="文件操作">文件操作<a href="post/shell#文件操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>cat</td><td style="text-align:center">显示或连接文件</td><td style="text-align:right">cat filename</td></tr><tr><td>od</td><td style="text-align:center">显示非文本文件的内容</td><td style="text-align:right">od -c filename</td></tr><tr><td>cp</td><td style="text-align:center">复制文件或目录</td><td style="text-align:right">cp file1 file2</td></tr><tr><td>rm</td><td style="text-align:center">删除文件或目录</td><td style="text-align:right">rm filename</td></tr><tr><td>mv</td><td style="text-align:center">改变文件名或所在目录</td><td style="text-align:right">mv file1 file2</td></tr><tr><td>find</td><td style="text-align:center">使用匹配表达式查找文件</td><td style="text-align:right">find . -name “*.c” -print</td></tr><tr><td>file</td><td style="text-align:center">显示文件类型</td><td style="text-align:right">file filename</td></tr></tbody></table></div></div><h1 id="选择操作">选择操作<a href="post/shell#选择操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>head</td><td style="text-align:center">显示文件的最初几行</td><td style="text-align:right">head -20 filename</td></tr><tr><td>tail</td><td style="text-align:center">显示文件的最后几行</td><td style="text-align:right">tail -15 filename</td></tr><tr><td>cut</td><td style="text-align:center">显示文件每行中的某些域</td><td style="text-align:right">cut -f1,7 -d: /etc/passwd</td></tr><tr><td>colrm</td><td style="text-align:center">从标准输入中删除若干列</td><td style="text-align:right">colrm 8 20 file2</td></tr><tr><td>diff</td><td style="text-align:center">比较并显示两个文件的差异</td><td style="text-align:right">diff file1 file2</td></tr><tr><td>sort</td><td style="text-align:center">排序或归并文件</td><td style="text-align:right">sort -d -f -u file1</td></tr><tr><td>uniq</td><td style="text-align:center">去掉文件中的重复行</td><td style="text-align:right">uniq file1 file2</td></tr><tr><td>comm</td><td style="text-align:center">显示两有序文件的公共和非公共行</td><td style="text-align:right">comm file1 file2</td></tr><tr><td>wc</td><td style="text-align:center">统计文件的字符数、词数和行数</td><td style="text-align:right">wc filename</td></tr><tr><td>nl</td><td style="text-align:center">给文件加上行号</td><td style="text-align:right">nl file1 &gt;file2</td></tr></tbody></table></div></div><h1 id="进程操作">进程操作<a href="post/shell#进程操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>ps</td><td style="text-align:center">显示进程当前状态</td><td style="text-align:right">ps u</td></tr><tr><td>kill</td><td style="text-align:center">终止进程</td><td style="text-align:right">kill -9 30142</td></tr></tbody></table></div></div><h1 id="时间操作">时间操作<a href="post/shell#时间操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>date</td><td style="text-align:center">显示系统的当前日期和时间</td><td style="text-align:right">date</td></tr><tr><td>cal</td><td style="text-align:center">显示日历</td><td style="text-align:right">cal 8 1996</td></tr><tr><td>time</td><td style="text-align:center">统计程序的执行时间</td><td style="text-align:right">time a.out</td></tr></tbody></table></div></div><h1 id="网络与通信操作">网络与通信操作<a href="post/shell#网络与通信操作"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>telnet</td><td style="text-align:center">远程登录</td><td style="text-align:right">telnet hpc.sp.net.edu.cn</td></tr><tr><td>rlogin</td><td style="text-align:center">远程登录</td><td style="text-align:right">rlogin hostname -l username</td></tr><tr><td>rsh</td><td style="text-align:center">在远程主机执行指定命令</td><td style="text-align:right">rsh f01n03 date</td></tr><tr><td>ftp</td><td style="text-align:center">在本地主机与远程主机之间传输文件</td><td style="text-align:right">ftp ftp.sp.net.edu.cn</td></tr><tr><td>rcp</td><td style="text-align:center">在本地主机与远程主机之间复制文件</td><td style="text-align:right">rcp file1 host1:file2</td></tr><tr><td>ping</td><td style="text-align:center">给一个网络主机发送 回应请求</td><td style="text-align:right">ping hpc.sp.net.edu.cn</td></tr><tr><td>mail</td><td style="text-align:center">阅读和发送电子邮件</td><td style="text-align:right">mail</td></tr><tr><td>write</td><td style="text-align:center">给另一用户发送报文</td><td style="text-align:right">write username pts/1</td></tr><tr><td>mesg</td><td style="text-align:center">允许或拒绝接收报文</td><td style="text-align:right">mesg n</td></tr></tbody></table></div></div><h1 id="Korn-Shell-命令">Korn Shell 命令<a href="post/shell#Korn-Shell-命令"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>history</td><td style="text-align:center">列出最近执行过的几条命令及编号</td><td style="text-align:right">history</td></tr><tr><td>r</td><td style="text-align:center">重复执行最近执行过的某条命令</td><td style="text-align:right">r -2</td></tr><tr><td>alias</td><td style="text-align:center">给某个命令定义别名</td><td style="text-align:right">alias del=rm -i</td></tr><tr><td>unalias</td><td style="text-align:center">取消对某个别名的定义</td><td style="text-align:right">unalias del</td></tr></tbody></table></div></div><h1 id="其它命令">其它命令<a href="post/shell#其它命令"></a></h1><div class="article-bounded"><div class="article-table"><table><thead><tr><th>命令名</th><th style="text-align:center">功能描述</th><th style="text-align:right">使用举例</th></tr></thead><tbody><tr><td>uname</td><td style="text-align:center">显示操作系统的有关信息</td><td style="text-align:right">uname -a</td></tr><tr><td>clear</td><td style="text-align:center">清除屏幕或窗口内容</td><td style="text-align:right">clear</td></tr><tr><td>env</td><td style="text-align:center">显示当前所有设置过的环境变量</td><td style="text-align:right">env</td></tr><tr><td>who</td><td style="text-align:center">列出当前登录的所有用户</td><td style="text-align:right">who</td></tr><tr><td>whoami</td><td style="text-align:center">显示当前正进行操作的用户名</td><td style="text-align:right">whoami</td></tr><tr><td>tty</td><td style="text-align:center">显示终端或伪终端的名称</td><td style="text-align:right">tty</td></tr><tr><td>stty</td><td style="text-align:center">显示或重置控制键定义</td><td style="text-align:right">stty -a</td></tr><tr><td>du</td><td style="text-align:center">查询磁盘使用情况</td><td style="text-align:right">du -k subdir</td></tr><tr><td>df</td><td style="text-align:center">显示文件系统的总空间和可用空间</td><td style="text-align:right">df /tmp</td></tr><tr><td>w</td><td style="text-align:center">显示当前系统活动的总信息</td><td style="text-align:right">w</td></tr></tbody></table></div></div>]]></content>
      
      
      <categories>
          
          <category> shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2019/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式">适配器模式<a href="post/设计模式#适配器模式"></a></h2><h3 id="有两个编译好的无源码的类，类a需要一个特定的功能才能可用。这个功能需要实现接口a。但是类b恰好有这个功能，但是实现的是接口b，这时需要写一个适配器。">有两个编译好的无源码的类，类a需要一个特定的功能才能可用。这个功能需要实现接口a。但是类b恰好有这个功能，但是实现的是接口b，这时需要写一个适配器。<a href="post/设计模式#有两个编译好的无源码的类，类a需要一个特定的功能才能可用。这个功能需要实现接口a。但是类b恰好有这个功能，但是实现的是接口b，这时需要写一个适配器。"></a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface XmlReader&#123;</span><br><span class="line">    public InputStream xmlReader();</span><br><span class="line">&#125;</span><br><span class="line">public interface ReaderXml&#123;</span><br><span class="line">    public InputStream readerXml();</span><br><span class="line">&#125;</span><br><span class="line">public class Adapter implements XmlReader extends B&#123;</span><br><span class="line">    public InputStream xmlReader()&#123;</span><br><span class="line">        return readerXml();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式所涉及的角色">适配器模式所涉及的角色<a href="post/设计模式#适配器模式所涉及的角色"></a></h3><ul><li>目标（CTarget）</li></ul><h4 id="定义一个客户端使用的特定接口">定义一个客户端使用的特定接口<a href="post/设计模式#定义一个客户端使用的特定接口"></a></h4><ul><li>客户（CClient）</li></ul><h4 id="使用目标接口，与目标接口一致的对象合作">使用目标接口，与目标接口一致的对象合作<a href="post/设计模式#使用目标接口，与目标接口一致的对象合作"></a></h4><ul><li>被适配者（CAdaptee）</li></ul><h4 id="一个现存需要匹配的接口">一个现存需要匹配的接口<a href="post/设计模式#一个现存需要匹配的接口"></a></h4><ul><li>适配器（CAdapter）</li></ul><h4 id="负责将CAdaptee接口转成CTarget接口">负责将CAdaptee接口转成CTarget接口<a href="post/设计模式#负责将CAdaptee接口转成CTarget接口"></a></h4><h3 id="适配器分为对象适配器和类适配器">适配器分为对象适配器和类适配器<a href="post/设计模式#适配器分为对象适配器和类适配器"></a></h3><ul><li>对象适配器包含一个适配器者的引用</li><li>类适配器：适配器内部调用他所继承的适配者的方法</li></ul><h3 id="EG">EG<a href="post/设计模式#EG"></a></h3><ul><li>电脑接口</li><li>插座</li></ul>]]></content>
      
      
      <categories>
          
          <category> Design pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Adapter Pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/05/05/hello-world/"/>
      <url>/2019/05/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start">Quick Start<a href="post/hello-world#Quick-Start"></a></h2><h3 id="Create-a-new-post">Create a new post<a href="post/hello-world#Create-a-new-post"></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server">Run server<a href="post/hello-world#Run-server"></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files">Generate static files<a href="post/hello-world#Generate-static-files"></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites<a href="post/hello-world#Deploy-to-remote-sites"></a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
