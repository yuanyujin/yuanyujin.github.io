{"meta":{"title":"yuanyujin's blog","subtitle":null,"description":null,"author":"yuanyujin","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"常用工具类","slug":"常用工具类","date":"2019-08-25T01:00:00.000Z","updated":"2019-08-25T02:45:45.292Z","comments":false,"path":"2019/08/25/常用工具类/","link":"http://yoursite.com/post/常用工具类/","permalink":"http://yoursite.com/2019/08/25/常用工具类/","excerpt":"","text":"org.apache.commons.io.IOUtils closeQuietly：关闭一个IO流、socket、或者selector且不抛出异常，通常放在finally块 toString：转换IO流、 Uri、 byte[]为String copy：IO流数据复制，从输入流写到输出流中，最大支持2GB toByteArray：从输入流、URI获取byte[] write：把字节. 字符等写入输出流 toInputStream：把字符转换为输入流 readLines：从输入流中读取多行数据，返回List copyLarge：同copy，支持2GB以上数据的复制 lineIterator：从输入流返回一个迭代器，根据参数要求读取的数据量，全部读取，如果数据不够，则失败 org.apache.commons.io.FileUtils deleteDirectory：删除文件夹 readFileToString：以字符形式读取文件内容 deleteQueitly：删除文件或文件夹且不会抛出异常 copyFile：复制文件 writeStringToFile：把字符写到目标文件，如果文件不存在，则创建 forceMkdir：强制创建文件夹，如果该文件夹父级目录不存在，则创建父级 write：把字符写到指定文件中 listFiles：列举某个目录下的文件(根据过滤器) copyDirectory：复制文件夹 forceDelete：强制删除文件 org.apache.commons.lang.StringUtils isBlank：字符串是否为空 (trim后判断) isEmpty：字符串是否为空 (不trim并判断) equals：字符串是否相等 join：合并数组为单一字符串，可传分隔符 split：分割字符串 EMPTY：返回空字符串 trimToNull：trim后为空字符串则转换为null replace：替换字符串 org.apache.http.util.EntityUtils toString：把Entity转换为字符串 consume：确保Entity中的内容全部被消费。可以看到源码里又一次消费了Entity的内容，假如用户没有消费，那调用Entity时候将会把它消费掉 toByteArray：把Entity转换为字节流 consumeQuietly：和consume一样，但不抛异常 getContentCharset：获取内容的编码 org.apache.commons.lang3.StringUtils isBlank：字符串是否为空 (trim后判断) isEmpty：字符串是否为空 (不trim并判断) equals：字符串是否相等 join：合并数组为单一字符串，可传分隔符 split：分割字符串 EMPTY：返回空字符串 replace：替换字符串 capitalize：首字符大写 org.apache.commons.io.FilenameUtils getExtension：返回文件后缀名 getBaseName：返回文件名，不包含后缀名 getName：返回文件全名 concat：按命令行风格组合文件路径(详见方法注释) removeExtension：删除后缀名 normalize：使路径正常化 wildcardMatch：匹配通配符 seperatorToUnix：路径分隔符改成unix系统格式的，即/ getFullPath：获取文件路径，不包括文件名 isExtension：检查文件后缀名是不是传入参数(List)中的一个 org.springframework.util.StringUtils hasText：检查字符串中是否包含文本 hasLength：检测字符串是否长度大于0 isEmpty：检测字符串是否为空（若传入为对象，则判断对象是否为null） commaDelimitedStringToArray：逗号分隔的String转换为数组 collectionToDelimitedString：把集合转为CSV格式字符串 replace 替换字符串 delimitedListToStringArray：相当于split uncapitalize：首字母小写 collectionToDelimitedCommaString：把集合转为CSV格式字符串 tokenizeToStringArray：和split基本一样，但能自动去掉空白的单词 org.apache.commons.lang.ArrayUtils contains：是否包含某字符串 addAll：添加整个数组 clone：克隆一个数组 isEmpty：是否空数组 add：向数组添加元素 subarray：截取数组 indexOf：查找某个元素的下标 isEquals：比较数组是否相等 toObject：基础类型数据数组转换为对应的Object数组 org.apache.http.client.utils.URLEncodedUtils format：格式化参数，返回一个HTTP POST或者HTTP PUT可用application/x-www-form-urlencoded字符串 parse：把String或者URI等转换为List org.apache.commons.codec.digest.DigestUtils md5Hex：MD5加密，返回32位字符串 sha1Hex：SHA-1加密 sha256Hex：SHA-256加密 sha512Hex：SHA-512加密 md5：MD5加密，返回16位字符串 org.apache.commons.collections.CollectionUtils isEmpty：是否为空 select：根据条件筛选集合元素 transform：根据指定方法处理集合元素，类似List的map() filter：过滤元素，类似List的filter() find：基本和select一样 collect：和transform 差不多一样，但是返回新数组 forAllDo：调用每个元素的指定方法 isEqualCollection：判断两个集合是否一致 org.apache.commons.lang3.ArrayUtils contains：是否包含某个字符串 addAll：添加整个数组 clone：克隆一个数组 isEmpty：是否空数组 add：向数组添加元素 subarray：截取数组 indexOf：查找某个元素的下标 isEquals：比较数组是否相等 toObject：基础类型数据数组转换为对应的Object数组 org.apache.commons.beanutils.PropertyUtils getProperty：获取对象属性值 setProperty：设置对象属性值 getPropertyDiscriptor：获取属性描述器 isReadable：检查属性是否可访问 copyProperties：复制属性值，从一个对象到另一个对象 getPropertyDiscriptors：获取所有属性描述器 isWriteable：检查属性是否可写 getPropertyType：获取对象属性类型 org.apache.commons.lang3.StringEscapeUtils unescapeHtml4：转义html escapeHtml4：反转义html escapeXml：转义xml unescapeXml：反转义xml escapeJava：转义unicode编码 escapeEcmaScript：转义EcmaScript字符 unescapeJava：反转义unicode编码 escapeJson：转义json字符 escapeXml10：转义Xml10 org.apache.commons.beanutils.BeanUtils copyPeoperties：复制属性值，从一个对象到另一个对象 getProperty：获取对象属性值 setProperty：设置对象属性值 populate：根据Map给属性复制 copyPeoperty：复制单个值，从一个对象到另一个对象 cloneBean：克隆bean实例","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"rocketmq安装","slug":"rocketmq安装","date":"2019-08-19T12:45:00.000Z","updated":"2019-08-19T15:31:10.549Z","comments":false,"path":"2019/08/19/rocketmq安装/","link":"http://yoursite.com/post/rocketmq安装/","permalink":"http://yoursite.com/2019/08/19/rocketmq安装/","excerpt":"","text":"RocketMQ简介RocketMQ是阿里巴巴中间件开发的分布式消息系统，曾经经历过很多阿里巴巴大型项目的实际检验。在去年已经正式捐献给Apache开源基金会，成为孵化项目。今年正式升级成为了apache的顶级项目。 RocketMQ官网地址为：http://rocketmq.apache.org/感兴趣的可以多多查看官网文档 准备工作安装环境本文所安装的RocketMQ为4.2.0版本，Linux系统版本为CentOS 7.2，安装目录为/usr/local/software/ 准备工具JavarocketMQ是使用Java开发的，所以需要在Linux系统内安装Java环境。 Maven项目下载下来之后需要使用Maven编译，所以需要提前安装。 安装RocketMQ下载RocketMQ wget https://github.com/apache/rocketmq/archive/rocketmq-all-4.2.0.tar.gz https://mirrors.tuna.tsinghua.edu.cn/apache/ 解压文件 tar -zxvf rocketmq-all-4.2.0.tar.gz 编译项目 mvn -Prelease-all -DskipTests clean install -U 配置环境变量编辑/etc/profile export rocketmq=/usr/local/software/rocketmq-rocketmq-all-4.2.0/distribution/target/apache-rocketmq export PATH= $ PATH:$rocketmq/bin 刷新环境变量 source /etc/profile 启动Nameserver nohup sh mqnamesrv &gt;/usr/local/logs/rocketmqlogs/mqnamesrv.log 2&gt;&amp;1 &amp; 启动Broker nohup sh mqbroker -n localhost:9876 &gt;/usr/local/logs/rocketmqlogs/broker.log 2&gt;&amp;1 &amp; 安装问题内存分配问题修改runserver.sh和runbroker.sh两个文件 JAVA_OPT=”${JAVA_OPT} -server -Xms=128m -Xmx=128m -Xmn=128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m”","categories":[{"name":"rocketmq","slug":"rocketmq","permalink":"http://yoursite.com/categories/rocketmq/"}],"tags":[{"name":"rocketmq","slug":"rocketmq","permalink":"http://yoursite.com/tags/rocketmq/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"java性能优化","slug":"性能优化","date":"2019-07-18T01:40:00.000Z","updated":"2019-07-20T12:48:10.475Z","comments":false,"path":"2019/07/18/性能优化/","link":"http://yoursite.com/post/性能优化/","permalink":"http://yoursite.com/2019/07/18/性能优化/","excerpt":"","text":"尽量指定类、方法的final修饰符带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50%。 尽量重用对象特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。 尽可能使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 及时关闭流Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。 尽量减少对变量的重复计算明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。 所以例如下面的操作： 12for (int i = 0; i &lt; list.size(); i++)&#123;...&#125; 建议替换为：12for (int i = 0, length = list.size(); i &lt; length; i++)&#123;...&#125; 这样，在list.size()很大的时候，就减少了很多的消耗 尽量采用懒加载的策略，即在需要的时候才创建例如：12345String str = &quot;aaa&quot;;if (i == 1)&#123; list.add(str);&#125; 建议替换为：12345if (i == 1)&#123; String str = &quot;aaa&quot;; list.add(str);&#125; 慎用异常异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 不要在循环中使用try…catch…，应该把其放在最外层根据网友们提出的意见，这一点我认为值得商榷，欢迎大家提出看法！ 如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例： StringBuilder()// 默认分配16个字符的空间 StringBuilder(int size) // 默认分配size个字符的空间 StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间 可以通过类（这里指的不仅仅是上面的StringBuilder）的构造函数来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。 因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么： 在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间把原来的4096个字符拷贝到新的的字符数组中去这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。 但是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 当复制大量数据时，使用System.arraycopy()命令乘法和除法使用移位操作例如：12345for (val = 0; val &lt; 100000; val += 5)&#123; a = val * 8; b = val / 2;&#125; 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：12345for (val = 0; val &lt; 100000; val += 5)&#123; a = val &lt;&lt; 3; b = val &gt;&gt; 1;&#125; 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 循环内不要不断创建对象引用例如：1234for (int i = 1; i &lt;= count; i++)&#123; Object obj = new Object(); &#125; 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：12345Object obj = null;for (int i = 0; i &lt;= count; i++)&#123; obj = new Object();&#125; 这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。 基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销不要将数组声明为public static final因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变 尽量在合适的场合使用单例使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： 控制资源的使用，通过线程同步来控制资源的并发访问控制实例的产生，以达到节约资源的目的控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 尽量避免随意使用静态变量要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如：1234public class A&#123; private static B b = new B(); &#125; 此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止 及时清除不再需要的会话为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate()方法清除会话。 实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。 实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。 可以使用类似如下的代码作判断：12345678910if (list instanceof RandomAccess)&#123; for (int i = 0; i &lt; list.size(); i++)&#123;&#125;&#125;else&#123; Iterator&lt;?&gt; iterator = list.iterable(); while (iterator.hasNext())&#123;iterator.next()&#125;&#125;` foreach循环的底层实现原理就是迭代器Iterator，可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。 http://www.cnblogs.com/xrq730/p/4868465.html 使用同步代码块替代同步方法这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。 http://www.cnblogs.com/xrq730/p/4851530.html 将常量声明为static final，并以大写命名这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量 不要创建一些不使用的对象，不要导入一些不使用的类这毫无意义，如果代码中出现The value of the local variable i is not used”、”The import java.util is never used，那么请删除这些无用的内容 程序运行过程中避免使用反射反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。 http://www.cnblogs.com/xrq730/p/4862111.html 使用数据库连接池和线程池这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程 使用带缓冲的输入输出流进行IO操作带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率 顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了 不要让public方法中有太多的形参public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处： 违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合参数太多势必导致方法调用的出错概率增加至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参 字符串变量和字符串常量equals的时候将字符串常量写在前面这是一个比较常见的小技巧了，如果有以下代码： 12345String str = &quot;123&quot;;if (str.equals(&quot;123&quot;))&#123; ...&#125; 建议修改为：12345String str = &quot;123&quot;;if (&quot;123&quot;.equals(str))&#123; ...&#125; 这么做主要是可以避免空指针异常 请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者平时有人问，if (i == 1)和if (1== i)有没有区别，这就要从C/C++讲起。 在C/C++中，if (i == 1)判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码：123456789int i = 2;if (i == 1)&#123; ...&#125;else&#123; ...&#125; C/C++判断i==1不成立，所以以0表示，即false。但是如果：123456789int i = 2;if (i = 1)&#123; ...&#125;else&#123; ...&#125; 万一程序员一个不小心，把if (i == 1)写成if (i = 1)，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建议将if语句写为：123456789int i = 2;if (1 == i)&#123; ...&#125;else&#123; ...&#125; 这样，即使开发者不小心写成了1 = i，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。 但是，在Java中，C/C++这种if (i = 1)的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错Type mismatch: cannot convert from int to boolean。但是，尽管Java的if (i == 1)和if (1 == i)在语义上没有任何区别，从阅读习惯上讲，建议使用前者会更好些。 不要对数组使用toString()方法看一下对数组使用toString()打印出来的是什么：12345public static void main(String[] args)&#123; int[] is = new int[]&#123;1, 2, 3&#125;; System.out.println(is.toString());&#125; 结果是： [I@18a992f本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections重写了Object的toString()方法。 不要对超出范围的基本数据类型做向下强制转型这绝不会得到想要的结果：123456public static void main(String[] args)&#123; long l = 12345678901234L; int i = (int)l; System.out.println(i);&#125; 我们可能期望得到其中的某几位，但是结果却是：1942892530 解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：0111 0011 1100 1110 0010 1111 1111 0010这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。 从这个例子上还能顺便得到两个结论： 整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是double，所以定义float的时候要写成float f = 3.5f接下来再写一句int ii = l + i;会报错，因为long + int是一个long，不能赋值给int 公用的集合类中不使用的数据一定要及时remove掉如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式 三种方式的效率如何，看一个测试：1234567891011121314151617181920212223public static void main(String[] args)&#123; int loopTime = 50000; Integer i = 0; long startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = String.valueOf(i); &#125; System.out.println(&quot;String.valueOf()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = i.toString(); &#125; System.out.println(&quot;Integer.toString()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = i + &quot;&quot;; &#125; System.out.println(&quot;i + \\&quot;\\&quot;：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);&#125; 运行结果为：123String.valueOf()：11msInteger.toString()：5msi + &quot;&quot;：25ms 所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。 至于为什么，很简单：String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断Integer.toString()方法就不说了，直接调用了i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串三者对比下来，明显是2最快、1次之、3最慢 使用最有效率的方式去遍历Map遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是： 12345678910111213public static void main(String[] args)&#123; HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); hm.put(&quot;111&quot;, &quot;222&quot;); Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet(); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); while (iter.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = iter.next(); System.out.println(entry.getKey() + &quot;\\t&quot; + entry.getValue()); &#125;&#125; 如果你只是想遍历一下这个Map的key值，那用Set keySet = hm.keySet();会比较合适一些 对资源的close()建议分开操作意思是，比如我有这么一段代码：123456789try&#123; XXX.close(); YYY.close();&#125;catch (Exception e)&#123; ...&#125; 建议修改为：12345678910111213141516try&#123; XXX.close();&#125;catch (Exception e)&#123; ...&#125;try&#123; YYY.close();&#125;catch (Exception e)&#123; ...&#125; 虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了catch块中了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保证了无论如何XXX和YYY都会被close掉 对于ThreadLocal使用前或者使用后一定要先remove当前基本所有的项目都使用了线程池技术，这非常好，可以动态配置线程数、可以重用线程。 然而，如果你在项目中使用到了ThreadLocal，一定要记得使用前或者使用后remove一下。这是因为上面提到了线程池技术做的是一个线程重用，这意味着代码运行过程中，一条线程使用完毕，并不会被销毁而是等待下一次的使用。我们看一下Thread类中，持有ThreadLocal.ThreadLocalMap的引用：123/* ThreadLocal values pertaining to this thread. This map is maintained by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 线程不销毁意味着上条线程set的ThreadLocal.ThreadLocalMap中的数据依然存在，那么在下一条线程重用这个Thread的时候，很可能get到的是上条线程set的数据而不是自己想要的内容。 这个问题非常隐晦，一旦出现这个原因导致的错误，没有相关经验或者没有扎实的基础非常难发现这个问题，因此在写代码的时候就要注意这一点，这将给你后续减少很多的工作量。 切记以常量定义的方式替代魔鬼数字，魔鬼数字的存在将极大地降低代码可读性，字符串常量是否使用常量定义可以视情况而定long或者Long初始赋值时，使用大写的L而不是小写的l，因为字母l极易与数字1混淆，这个点非常细节，值得注意所有重写的方法必须保留@Override注解这么做有三个原因： 清楚地可以知道这个方法由父类继承而来getObject()和get0bject()方法，前者第四个字母是”O”，后者第四个子母是”0”，加了@Override注解可以马上判断是否重写成功在抽象类中对方法签名进行修改，实现类会马上报出编译错误 推荐使用JDK7中新引入的Objects工具类来进行对象的equals比较，直接a.equals(b)，有空指针异常的风险循环体内不要使用”+”进行字符串拼接，而直接使用StringBuilder不断append说一下不使用”+”进行字符串拼接的原因，假如我有一个方法： 1234567891011public String appendStr(String oriStr, String... appendStrs) &#123; if (appendStrs == null || appendStrs.length == 0) &#123; return oriStr; &#125; for (String appendStr : appendStrs) &#123; oriStr += appendStr; &#125; return oriStr;&#125; 将这段代码编译之后的.class文件，使用javap -c进行反编译一下，截取关键的一部分： 意思就是每次虚拟机碰到”+”这个操作符对字符串进行拼接的时候，会new出一个StringBuilder，然后调用append方法，最后调用toString()方法转换字符串赋值给oriStr对象，即循环多少次，就会new出多少个StringBuilder()来，这对于内存是一种浪费。 不捕获Java类库中定义的继承自RuntimeException的运行时异常类异常处理效率低，RuntimeException的运行时异常类，其中绝大多数完全可以由程序员来规避，比如： ArithmeticException可以通过判断除数是否为空来规避NullPointerException可以通过判断对象是否为空来规避IndexOutOfBoundsException可以通过判断数组/字符串长度来规避ClassCastException可以通过instanceof关键字来规避ConcurrentModificationException可以使用迭代器来规避 避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降，JDK7之后，可以使用ThreadLocalRandom来获取随机数解释一下竞争同一个seed导致性能下降的原因，比如，看一下Random类的nextInt()方法实现： 123public int nextInt() &#123; return next(32);&#125; 调用了next(int bits)方法，这是一个受保护的方法：123456789protected int next(int bits) &#123; long oldseed, nextseed; AtomicLong seed = this.seed; do &#123; oldseed = seed.get(); nextseed = (oldseed * multiplier + addend) &amp; mask; &#125; while (!seed.compareAndSet(oldseed, nextseed)); return (int)(nextseed &gt;&gt;&gt; (48 - bits));&#125; 而这边的seed是一个全局变量： 123456/** * The internal state associated with this pseudorandom number generator. * (The specs for the methods in this class describe the ongoing * computation of this value.) */private final AtomicLong seed; 多个线程同时获取随机数的时候，会竞争同一个seed，导致了效率的降低。 静态类、单例类、工厂类将它们的构造函数置为private这是因为静态类、单例类、工厂类这种类本来我们就不需要外部将它们new出来，将构造函数置为private之后，保证了这些类不会产生实例对象。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"http and https","slug":"httpandhttps","date":"2019-05-31T13:10:00.000Z","updated":"2019-06-07T02:47:23.265Z","comments":false,"path":"2019/05/31/httpandhttps/","link":"http://yoursite.com/post/httpandhttps/","permalink":"http://yoursite.com/2019/05/31/httpandhttps/","excerpt":"","text":"网络层结构 OSI是指Open System Interconnect，意为开放式系统互联。 TCP/IP是指传输控制协议/网间协议，是目前世界上应用最广的协议 对应tcp/ip层 osi各层功能 网络协议 应用层 应用程序（电子邮件、文件服务）、用户接口 HTTP、FTP、TFTP、NFS 应用层 数据的表示、压缩和加密（数据格式化、代码转换、数据加密） TELNET、SNMP 应用层 建立、管理和终止会话 SMTP、DNS 传输层 提供端到端可靠报文传递和错误恢复 TCP、UDP 国际互联层 提供数据包从源到宿的传递和网际交互 IP、ICMP、ARP、RARP、UUCP 网络接口层 将比特组装成桢和点到点传递 FDDI、SLIP、PPP、PDN 网络接口层 传输比特流，以二进制数据形式在物理媒体上传输数据 ISO2110、IEEE802、IEEE802.2 两种模型的区别 OSI采用七层模型，TCP/IP采用四层模型。 TCP/IP网络接口层没有真正的定义，只是概念性的描述。OSI把它分为2层，每一层功能详尽。 在协议开发之前，就有了OSI模型，所以OSI模型具有共通性，而TCP/IP是基于协议建立的模型，不适用于非TCP/IP的网络。 实际应用中，OSI模型是理论上的模型，没有成熟的产品；而TCP/IP已经成为国际标准。 HTTP协议Http是基于TCP/IP协议的应用程序协议，不包括数据包的传输，主要规定了客户端和服务器的通信格式，默认使用80端口。 发展历史 1991年发布Http/0.9版本，只有Get命令，且服务端直返HTML格式字符串，服务器响应完毕就关闭TCP连接。 1996年发布Http/1.0版本，优点：可以发送任何格式内容，包括文字、图像、视频、二进制。也丰富了命令Get，Post，Head。请求和响应的格式加入头信息。缺点：每个TCP连接只能发送一个请求，而新建TCP连接的成本很高，导致Http/1.0新能很差。 1997发布Http/1.1版本，完善了Http协议，直至20年后的今天仍是最流行的版本。优点如下 引入持久连接，TCP默认不关闭，可被多个请求复用，对于一个域名，多数浏览器允许同时建立6个持久连接。 引入管道机制，即在同一个TCP连接中，可以同时发送多个请求，不过服务器还是按顺序响应。 在头部加入Content-Length字段，一个TCP可以同时传送多个响应，所以就需要该字段来区分哪些内容属于哪个响应。 分块传输编码，对于耗时的动态操作，用流模式取代缓存模式，即产生一块数据，就发送一块数据。 增加了许多命令，头信息增加Host来指定服务器域名，可以访问一台服务器上的不同网站。 2015年发布Http/2版本，它有几个特性：二进制协议、多工、数据流、头信息压缩、服务器推送。 http请求和响应格式request格式：12345678GET /barite/account/stock/groups HTTP/1.1QUARTZ-SESSION: MC4xMDQ0NjA3NTI0Mzc0MjAyNg.VPXuA8rxTghcZlRCfiAwZlAIdCADEVICE-TYPE: ANDROIDAPI-VERSION: 15Host: shitouji.bluestonehk.comConnection: Keep-AliveAccept-Encoding: gzipUser-Agent: okhttp/3.10.0 response格式123456789101112HTTP/1.1 200 OKServer: nginx/1.6.3Date: Mon, 15 Oct 2018 03:30:28 GMTContent-Type: application/json;charset=UTF-8Pragma: no-cacheCache-Control: no-cacheExpires: Thu, 01 Jan 1970 00:00:00 GMTContent-Encoding: gzipTransfer-Encoding: chunkedProxy-Connection: Keep-alive&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125; Host:指定服务器域名，可用来区分访问一个服务器上的不同服务 Connection：keep-alive（默认值）表示要求服务器不要关闭TCP。close表示明确要求关闭连接 Accept-Encoding：用户代理，是服务器能识别客户端的操作系统（Android，IOS，WEB）及相关的信息。作用是帮助服务器区分客户端，并且针对不同客户端让用户看到不同数据，做不同的操作。 Content-Type：服务器告诉客户端数据的格式，常见的值有text/plain、image/jpeg、image/png、video/mp4、application/json、application/zip，这些数据类型总称为MIMETYPE。 Content-Encodiing：chunked表示采用分块传输编码、有该字段则无需使用Content-Length字段。 Content-Length：声明数据的长度。请求和回应头部都可以使用该字段。 TCP三次握手http和https协议请求时都会通过tcp三次握手建立tcp连接。 第一次握手，A向B发送信息后，B收到消息，B可以确认A的发信能力和B的收信能力。 第二次握手，B向A发消息，A收到消息，A可确认A的发信能力和收信能力，A也可确认B的收信能力和发信能力。 第三次握手，A向B发送信息，B接收信息。B可确认A的收信能力和B的发信能力 ACK：响应标识，1表示响应，连接建立成功后，所有的报文段ACK的值都为1 SYN：连接标识，1表示建立连接，连接请求和连接接受报文段SYN=1，其他情况都是0 FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段FIN=1，其他情况都是0，跟SYN类似。 seq number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有 ack number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段。 三次握手具体流程 第一次握手：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。 第二次握手：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack=x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq=y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。 第三次握手：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成Tcp三次握手。 数据传输完毕，需要断开连接，断开连接需要经历四次挥手 第一次挥手：主机1（可以是客户端或服务器），设置seq和ack向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1状态，表示没有数据要发送给主机2了 第二次挥手：主机2收到主机1的FIN报文段，向主机1回应一个ACK报文段，表示同意关闭请求，主机1进入FIN_WAIT_2状态。 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，主机2进入LAST_ACK状态。 第四次挥手：主机1收到主机2的FIN报文段，想主机2回应ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段后，关闭连接。此时主机1等待主机2一段时间后，没有收到回复，证明主机2已经正常关闭，主机1页关闭连接。 Https协议/SSL协议Https协议是以安全为目标的Http通道，简单来说就是Http的安全版。主要是在Http下加入SSL层（现在主流的是SLL/TLS），SSL是Https协议的安全基础。Https默认端口号为443。 http风险 窃听风险：Http采用明文传输数据，第三方可以用获知通信内容 篡改风险：第三方可以修改通信内容 冒充风险：第三方可以冒充他人身份进行通信 SSL/TLS协议就是为了解决这些风险而设计 所有信息加密传输，三方窃听通信内容 具有校验机制，内容一旦被篡改，通信双发立刻会发现 配备身份证书，防止身份被冒充 SSL发展史 1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。 1995年NetSpace发布SSL/2.0版本，很快发现有严重漏洞 1996年发布SSL/3.0版本，得到大规模应用 1999年，发布了SSL升级版TLS/1.0版本，目前应用最广泛的版本 2006年和2008年，发布了TLS/1.1版本和TLS/1.2版本 SSL原理及运行过程SSL/TLS协议基本思路是采用公钥加密法（最有名的是RSA加密算法）。大概流程是，客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。 为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。 过程 客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式 服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random） 客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端 服务端使用自己的私钥解密出C 客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。 SSL证书SSL证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，需要从经销商购买。 证书按照认证级别分类 域名认证（DV=Domain Validation）：最低级别的认证，可以确认申请人拥有这个域名 公司认证（OV=Organization Validation）：确认域名所有人是哪家公司，证书里面包含公司的信息 扩展认证（EV=Extended Validation）：最高级别认证，浏览器地址会显示公司名称 按覆盖范围分类 单域名证书：只能用于单域名 foo.com证书不用于www.foo.com 通配符证书：可用于某个域名及所有一级子域名，比如*.foo.com的证书可用于foo.com，也可以用于www.foo.com 多域名证书：可用于多个域名，比如foo.com和bar.com 认证级别越高，覆盖范围越广的证书，价格越贵。也有免费的证书，为了推广Https，电子前哨基金会成立了Let’s Encrypt提供免费证书。 RSA加密和DH加密加密算法分类 对称加密：甲方和乙方使用同一种加密规则对信息加解密 非对称加密：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。 Hash加密：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程 对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA 非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用（对称加密通信内容，非对称加密对称秘钥）。常见的非对称加密算法有RSA、DH、DSA、ECC Hash算法特性是：输入值一样，经过哈希函数得到相同的散列值，但并非散列值相同则输入值也相同。常见的Hash加密算法有MD5、SHA-1、SHA-X系列 Http协议和Https协议的对比 https协议需要到CA申请证书，大多数情况下需要一定费用 Http是超文本传输协议，信息采用明文传输，Https则是具有安全性SSL加密传输协议 Http和Https端口号不一样，Http是80端口，Https是443端口 Http连接是无状态的，而Https采用Http+SSL构建可进行加密传输、身份认证的网络协议，更安全 Http协议建立连接的过程比Https协议快。因为Https除了Tcp三次握手，还要经过SSL握手。连接建立之后数据传输速度，二者无明显区别。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"}]},{"title":"java8新特性lambda表达式、方法引用、函数式接口、默认方式、静态方法","slug":"java8部分新特性","date":"2019-05-20T01:00:00.000Z","updated":"2019-05-20T00:52:05.100Z","comments":false,"path":"2019/05/20/java8部分新特性/","link":"http://yoursite.com/post/java8部分新特性/","permalink":"http://yoursite.com/2019/05/20/java8部分新特性/","excerpt":"","text":"lambda 表达式线程的用法原始的线程用法 1234567//使用匿名内部类的方式启动多线程new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;这是使用匿名内部类的方式。。。&quot;); &#125;&#125;).start(); lambda表达式 1234//使用lambda表达式方式new Thread(() -&gt; &#123; System.out.println(&quot;这是使用lambda表达式的方式。。。&quot;);&#125;).start(); 遍历方式原始方式 12345//原始方式List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);for (int i : list) &#123; System.out.println(i);&#125; lambda表达式 1234//使用lambda表达式代替foreach循环Stream.of(1, 2, 3, 4, 5).forEach((x) -&gt; &#123; System.out.println(x);&#125;); 总结 12([参数可选，...]) -&gt; &#123;&#125; 方法引用方法引用其实是 lambda 表达式的部分的简化。1234567891011121314151617181920212223242526@Testpublic void test_method_reference() &#123; //使用lambda表达式 Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;) .map(s -&gt; s.length()) //lambda .forEach((x) -&gt; &#123; System.out.println(x); &#125;); //使用静态方法引用 Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;) .map(String::length) //静态方法引用 .forEach((x) -&gt; &#123; System.out.println(x); &#125;); //使用实例方法引用 Stream.of( new ClassMate(&quot;1&quot;, &quot;欧阳思海&quot;), new ClassMate(&quot;2&quot;, &quot;sihai&quot;) ).map(ClassMate::getName)//实例方法引用 .forEach(x -&gt; &#123; System.out.println(x); &#125;);&#125; 第一个使用lambda表达式获取每个字符串的长度s -&gt; s.length()第二个使用静态方法获取每个字符串的长度String::length第三个使用实例方法引用ClassMate::getName 解释 map方法是映射的意思 forEach方法是遍历每一个元素 总结 使用方法 类名::方法 方法可以是静态方法和实例方法 构造函数引用123456789101112@Testpublic void test_method_reference2() &#123; //使用lambda表达式 Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;) .map(s -&gt; new ClassMate(s)) //lambda .collect(Collectors.toList()); //使用构造函数引用 Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;) .map(ClassMate::new) //构造函数引用,由上下文决定用哪一个构造函数 .collect(Collectors.toList());&#125; 第一个我们使用的是 lambda 表达式进行创建对象的 s -&gt; new ClassMate(s)。 第二个我们使用的是构造函数引用创建对象的 ClassMate::new 。 我们发现构造函数引用：类名::new ，然后对于使用哪一个构造函数是由上下文决定的，比如有一个参数和两个参数和无参数的构造函数，会自动确定用哪一个。 接口在 Java 8 之前的接口是不能有实现的，只能定义抽象方法，然而，在 Java 8 以后，增加了一个新的功能，可以添加实现，可以定义默认方法，可以定义静态方法。 函数式接口在一个接口中我们以 @FunctionalInterface 注解声明一个接口，并且接口中只有一个抽象方法，那么我们就叫做这是一个函数式接口。 12345@FunctionalInterfacepublic interface FunctionalInterfaceTest &#123; //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口 void test(String s);&#125; 默认方法默认方法很简单，用 default 声明即可。 12345678910@FunctionalInterfacepublic interface FunctionalInterfaceTest &#123; //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口 void test(String s); //默认方法 default String getStr()&#123; return null; &#125;&#125; 静态方法123456789101112131415@FunctionalInterfacepublic interface FunctionalInterfaceTest &#123; //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口 void test(String s); //静态方法 static String getStr()&#123; return null; &#125; //错误用法 default static String getStr3()&#123; return null; &#125;&#125; 实现的静态方法，用 static 声明。 注意不能同时使用 default 和 static 声明。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Lambda","slug":"Lambda","permalink":"http://yoursite.com/tags/Lambda/"}]},{"title":"Method类","slug":"Method","date":"2019-05-18T12:00:00.000Z","updated":"2019-05-18T14:28:43.933Z","comments":false,"path":"2019/05/18/Method/","link":"http://yoursite.com/post/Method/","permalink":"http://yoursite.com/2019/05/18/Method/","excerpt":"","text":"Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。 一个完整方法包含的属性有： 方法上使用的注解 方法的修饰符 方法上定义的泛型参数 方法的返回值 方法名称 方法参数(泛型、注解) 方法抛出的异常 1234567891011121314151617@MyAnnotationpublic &lt;T&gt; boolean add(List&lt;T&gt; list,T...params)throws RuntimeException,Exception&#123; if(null==list)&#123; throw new RuntimeException(&quot;list=null&quot;); &#125; if(null==params)&#123; return false; &#125; //将参数添加到List集合中 if(null!=params)&#123; for(T t:params)&#123; list.add(t); &#125; &#125; return true;&#125; 注解：@MyAnnotation 修饰符：public 泛型参数：T 返回值：boolean 方法名：add 方法参数(泛型、注解)：List list，T…params 抛出的异常：RuntimeException，Exception 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public class MethodTest &#123; /** * 一个完整方法包含的属性有： 方法上使用的注解、方法的修饰符、方法上定义的泛型参数、方法的返回值、方法名称、方法参数(泛型、注解)、方法抛出的异常 */ @MyAnnotation private &lt;T&gt; boolean add(@MyAnnotation List&lt;T&gt; list, T... params) throws RuntimeException, Exception &#123; if (null == list) &#123; throw new RuntimeException(&quot;list=null&quot;); &#125; if (null == params) &#123; return false; &#125; // 将参数添加到List集合中 if (null != params) &#123; for (T t : params) &#123; list.add(t); &#125; &#125; return true; &#125; public static void main(String[] args) throws Exception &#123; // 获取Method MethodTest obj = new MethodTest(); Class&lt;? extends MethodTest&gt; clazz = obj.getClass(); Method method = clazz.getDeclaredMethod(&quot;add&quot;, List.class, Object[].class); if (!method.isAccessible()) &#123; method.setAccessible(true); &#125; //获取方法基本信息 getMethodInfo(method); // 调用方法 List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); method.invoke(obj, arrayList, new String[] &#123; &quot;1&quot;, &quot;2&quot; &#125;); System.out.println(arrayList);//[1,2] //方法定义所在的类 Class&lt;?&gt; declaringClass = method.getDeclaringClass(); // 如果此方法是 bridge 方法，则返回 true； boolean bridge = method.isBridge(); //如果该方法是public非抽象非静态，且定义在接口中，则返回true boolean default1 = method.isDefault(); //false //如果此方法为复合方法，则返回 true； boolean synthetic = method.isSynthetic();//false // 如果将此方法的参数带有可变参数，则返回 true boolean varArgs = method.isVarArgs(); //true &#125; private static void getMethodInfo(Method method) &#123; // 1、获取方法上的注解 boolean annotationPresent = method .isAnnotationPresent(MyAnnotation.class); if (annotationPresent) &#123; MyAnnotation myAnnotation = method .getDeclaredAnnotation(MyAnnotation.class); &#125; // 2、方法的修饰符 int modifiers = method.getModifiers(); String modify = Modifier.toString(modifiers);// private // 3、方法上定义的泛型参数 TypeVariable&lt;Method&gt;[] typeParameters = method.getTypeParameters();// [T] // 4、方法的返回值 Class&lt;?&gt; returnType = method.getReturnType();// boolean Type genericReturnType = method.getGenericReturnType();// boolean // 5、方法名称 String name = method.getName(); // 6、方法参数 int parameterCount = method.getParameterCount();// 参数个数 2 // 方法参数——泛型 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); // 打印 [interface java.util.List, class [Ljava.lang.Object;] Type[] genericParameterTypes = method.getGenericParameterTypes(); // 打印 [java.util.List&lt;T&gt;, T[]] for (Type type : genericParameterTypes) &#123; if (type instanceof ParameterizedType) &#123; // 参数类型 System.out.println(&quot;ParameterizedType类型：&quot; + type); ParameterizedType parameterizedType = (ParameterizedType) type; Type[] actualTypeArguments = parameterizedType .getActualTypeArguments(); System.out.println(&quot;实际参数为：&quot; + Arrays.toString(actualTypeArguments)); for (Type actualType : actualTypeArguments) &#123; if (actualType instanceof WildcardType) &#123; WildcardType wildcardType = (WildcardType) actualTypeArguments[0]; System.out.println(&quot;实际参数为WildcardType类型：&quot; + wildcardType.getUpperBounds()); &#125; else if (actualType instanceof Class) &#123; System.out.println(&quot;实际参数为Class类型：&quot; + actualType); &#125; &#125; &#125; else if (type instanceof GenericArrayType) &#123; // 泛型数组类型 T[] GenericArrayType genericArrayType = (GenericArrayType) type; System.out.println(&quot;GenericArrayType类型：&quot; + genericArrayType.getGenericComponentType());//T &#125; else if (type instanceof TypeVariable) &#123; // 泛型变量 System.out.println(&quot;TypeVariable类型：&quot; + type); &#125; else if (type instanceof Class) &#123; // System.out.println(&quot;Class类型：&quot; + type); &#125; &#125; /* * 方法有2个参数，第一个参数list为ParameterizedType，实际参数为T， * 第二个参数为GenericArrayType泛型数组类型T[],数组元素类型为T */ //方法参数——注解 第一个参数使用了注解 Annotation[][] parameterAnnotations = method.getParameterAnnotations(); Annotation myAnnotation=parameterAnnotations[0][0]; //打印 @reflect.MyAnnotation(intValue=0) // 7、方法抛出的异常 Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes(); // 打印 [class java.lang.RuntimeException, class java.lang.Exception] Type[] genericExceptionTypes = method.getGenericExceptionTypes(); // 打印 [class java.lang.RuntimeException, class java.lang.Exception] &#125;&#125; Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象,如果参数为基本类型数据,必须转换为相应的包装类型的对象。invoke()方法的返回值总是对象,如果实际被调用的方法的返回类型是基本类型数据,那么invoke()方法会把它转换为相应的包装类型的对象,再将其返回.","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"Method","slug":"Method","permalink":"http://yoursite.com/tags/Method/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Field类","slug":"Field","date":"2019-05-18T12:00:00.000Z","updated":"2019-05-18T14:05:13.713Z","comments":false,"path":"2019/05/18/Field/","link":"http://yoursite.com/post/Field/","permalink":"http://yoursite.com/2019/05/18/Field/","excerpt":"","text":"Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。 Field 成员变量的介绍 每个成员变量有类型和值。java.lang.reflect.Field 为我们提供了获取当前对象的成员变量的类型，和重新设值的方法。 获取变量的类型类中的变量分为两种类型：基本类型和引用类型： 基本类型（ 8 种） 整数：byte, short, int, long 浮点数：float, double 字符：char 布尔值：boolean 引用类型 所有的引用类型都继承自 java.lang.Object 类，枚举，数组，接口都是引用类型 java.io.Serializable 接口，基本类型的包装类（比如 java.lang.Double）也是引用类型 java.lang.reflect.Field 提供了两个方法获去变量的类型： Field.getType()：返回这个变量的类型 Field.getGenericType()：如果当前属性有签名属性类型就返回，否则就返回 Field.getType() field.getType()和field.getGenericType()的区别就是返回类型不一样 获取成员变量的修饰符成员变量可以被以下修饰符修饰： 访问权限控制符：public, protected, private 限制只能有一个实例的：static 不允许修改的：final 不会被序列化：transient 线程共享数据的一致性：volatile 注解 类似获取 Class 的修饰符，我们可以使用 Field.getModifiers() 方法获取当前成员变量的修饰符。返回 java.lang.reflect.Modifier 中定义的整形值。然后使用 Modifier.toString(int mod)解码成字符串 由于 Field 间接继承了 java.lang.reflect.AnnotatedElement ，因此运行时也可以获得修饰成员变量的注解，当然前提是这个注解被 java.lang.annotation.RetentionPolicy.RUNTIME 修饰。 获取和修改成员变量的值拿到一个对象后，我们可以在运行时修改它的成员变量的值，对运行时来说，反射修改变量值的操作和类中修改变量的结果是一样的。 基本类型的getter方法 12345678910111213141516byte getByte(Object obj) 获取一个静态或实例 byte 字段的值。 int getInt(Object obj) 获取 int 类型或另一个通过扩展转换可以转换为 int 类型的基本类型的静态或实例字段的值。 short getShort(Object obj) 获取 short 类型或另一个通过扩展转换可以转换为 short 类型的基本类型的静态或实例字段的值。 long getLong(Object obj) 获取 long 类型或另一个通过扩展转换可以转换为 long 类型的基本类型的静态或实例字段的值。 float getFloat(Object obj) 获取 float 类型或另一个通过扩展转换可以转换为 float 类型的基本类型的静态或实例字段的值。 double getDouble(Object obj) 获取 double 类型或另一个通过扩展转换可以转换为 double 类型的基本类型的静态或实例字段的值。 boolean getBoolean(Object obj) 获取一个静态或实例 boolean 字段的值。 char getChar(Object obj) 获取 char 类型或另一个通过扩展转换可以转换为 char 类型的基本类型的静态或实例字段的值。 基本类型的setter 12345678910111213141516void setByte(Object obj, byte b) 将字段的值设置为指定对象上的一个 byte 值。 void setShort(Object obj, short s) 将字段的值设置为指定对象上的一个 short 值。 void setInt(Object obj, int i) 将字段的值设置为指定对象上的一个 int 值。 void setLong(Object obj, long l) 将字段的值设置为指定对象上的一个 long 值。 void setFloat(Object obj, float f) 将字段的值设置为指定对象上的一个 float 值。 void setDouble(Object obj, double d) 将字段的值设置为指定对象上的一个 double 值。 void setBoolean(Object obj, boolean z) 将字段的值设置为指定对象上的一个 boolean 值。 void setChar(Object obj, char c) 将字段的值设置为指定对象上的一个 char 值。 引用类型的getter 12Object get(Object obj) 返回指定对象上此 Field 表示的字段的值。 引用类型的setter 12void set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 再说一下setAccessible()方法，Field的setAccessible()方法是从AccessibleObject类继承而来的。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了在使用时 取消默认 Java 语言访问控制检查的能力。一般情况下，我们并不能对类的私有字段进行操作，利用反射也不例外，但有的时候，例如要序列化的时候，我们又必须有能力去处理这些字段，这时候，我们就需要调用AccessibleObject上的setAccessible()方法来允许这种访问，而由于反射类中的Field，Method和Constructor继承自AccessibleObject，因此，通过在Field，Method和Constructor这些类上调用setAccessible()方法，我们可以操作这些字段无法访问的字段。 其他方法 boolean 123456boolean equals(Object obj) 将此 Field 与指定对象比较。 boolean isEnumConstant() 如果此字段表示枚举类型的元素，则返回 true；否则返回 false。 boolean isSynthetic() 如果此字段是复合字段，则返回 true；否则返回 false。 String 123456String getName() 返回此 Field 对象表示的字段的名称。 String toGenericString() 返回一个描述此 Field（包括其一般类型）的字符串。 String toString() 返回一个描述此 Field 的字符串。 其他 1234int hashCode() 返回该 Field 的哈希码。boolean equals(Object obj) 将此 Field 与指定对象比较。 equals()和hashCode() 12&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。 返回注释的方法： 12Annotation[] getDeclaredAnnotations() 返回直接存在于此元素上的所有注释。 返回字段所在的类或者接口的Class对象 12Class&lt;?&gt; getDeclaringClass() 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段。 返回字段的类型（Type） 12Type getGenericType() 返回一个 Type 对象，它表示此 Field 对象所表示字段的声明类型。 返回修饰符编码 12int getModifiers() 以整数形式返回由此 Field 对象表示的字段的 Java 语言修饰符。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Field","slug":"Field","permalink":"http://yoursite.com/tags/Field/"}]},{"title":"反射","slug":"反射","date":"2019-05-18T12:00:00.000Z","updated":"2019-05-18T13:41:24.846Z","comments":false,"path":"2019/05/18/反射/","link":"http://yoursite.com/post/反射/","permalink":"http://yoursite.com/2019/05/18/反射/","excerpt":"","text":"概念反射就是把java的各种成分映射成相应的java类 Class类的构建方法是private，由jvm创建 反射是java语言的一个特性，它允程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个java的类获取他所有的成员变量和方法并且显示出来。 Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 基本的 Java类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。 在没有对象实例的时候，主要有两种方法1234Class clazz1 = Role.class;Class clazz2 = Class.forName(&quot;yu.Role&quot;);Object o = cls1.newInstance(); 在第二种方法中，forName中的参数一定是完整的类名（包名+类名），并且这个方法需要捕获异常。现在得到cls1就可以创建一个Role类的实例了，利用Class的newInstance方法相当于调用类的默认的构造器。 常用方法 getConstructor(Class&lt;?&gt;… parameterTypes) 返回Constructor反映此Class 对象所表示的类的指定公共构造函数的对象。 getConstructors() 返回一个数组，其中包含Constructor反映此Class对象所表示的类的所有公共构造函数的 对象。 getDeclaredFields() 返回一个Field对象数组，反映由此Class对象表示的类或接口声明的所有字段 。 getDeclaredField(String name) 返回一个Field对象，该对象反映此Class 对象表示的类或接口的指定声明字段。 getDeclaredMethods() 返回一个数组，其中包含Method反映此Class对象所表示的类或接口的所有声明方法的对象，包括public，protected，default（包）访问和私有方法，但不包括继承的方法。 getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个Method对象，该对象反映此Class对象表示的类或接口的指定声明方法 。 getName() 返回此Class对象表示的实体名称（类，接口，数组类，基本类型或void），如String。 isPrimitive() 确定指定的Class对象是否表示基本类型。 例题 将所有String类型的成员变量里的b改成a。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.lang.reflect.Field;public class TestReflect &#123; public static void main(String[] args) throws SecurityException, NoSuchMethodException, NoSuchFieldException, IllegalArgumentException, Exception &#123; ReflectPointer rp1 = new ReflectPointer(3,4); changeBtoA(rp1); System.out.println(rp1); &#125; private static void changeBtoA(Object obj) throws RuntimeException, Exception &#123; Field[] fields = obj.getClass().getFields(); for(Field field : fields) &#123; //if(field.getType().equals(String.class)) //由于字节码只有一份,用equals语义不准确 if(field.getType()==String.class) &#123; String oldValue = (String)field.get(obj); String newValue = oldValue.replace(&apos;b&apos;, &apos;a&apos;); field.set(obj,newValue); &#125; &#125; &#125;&#125;class ReflectPointer &#123; private int x = 0; public int y = 0; public String str1 = &quot;ball&quot;; public String str2 = &quot;basketball&quot;; public ReflectPointer(int x,int y) &#123; super(); this.x = x; this.y = y; &#125; @Override public String toString() &#123; return &quot;ReflectPointer [str1=&quot; + str1 + &quot;, str2=&quot; + str2 + &quot;, str3=&quot; + str3 + &quot;]&quot;; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"reflection","slug":"reflection","permalink":"http://yoursite.com/tags/reflection/"}]},{"title":"rocketmq-console搭建","slug":"rocketmq-console","date":"2019-05-14T01:40:00.000Z","updated":"2019-05-14T01:53:06.008Z","comments":false,"path":"2019/05/14/rocketmq-console/","link":"http://yoursite.com/post/rocketmq-console/","permalink":"http://yoursite.com/2019/05/14/rocketmq-console/","excerpt":"","text":"源码 rocketmq的开源拓展项目rocketmq-externals 选择子模块rocketmq-console 修改配置 配置文件路径：rocketmq-console/src/main/resources/application.properties URL rocketmq.config.namesrvAddr=mq的ip:port 项目启动端口 server.port=8080 如果提示10909链接失败 rocketmq.config.isVIPChannel=修改为false eg：12345678910111213141516171819202122232425262728293031server.contextPath=#服务运行端口server.port=8080### SSL setting#server.ssl.key-store=classpath:rmqcngkeystore.jks#server.ssl.key-store-password=rocketmq#server.ssl.keyStoreType=PKCS12#server.ssl.keyAlias=rmqcngkey#spring.application.index=truespring.application.name=rocketmq-consolespring.http.encoding.charset=UTF-8spring.http.encoding.enabled=truespring.http.encoding.force=truelogging.config=classpath:logback.xml#if this value is empty,use env value rocketmq.config.namesrvAddr NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876#监听mq服务地址，多个用逗号隔开rocketmq.config.namesrvAddr=localhost:9876#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default truerocketmq.config.isVIPChannel=#rocketmq-console&apos;s data path:dashboard/monitorrocketmq.config.dataPath=/tmp/rocketmq-console/data#set it false if you don&apos;t want use dashboard.default truerocketmq.config.enableDashBoardCollect=true#set the message track trace topic if you don&apos;t want use the default onerocketmq.config.msgTrackTopicName=rocketmq.config.ticketKey=ticket#Must create userInfo file: $&#123;rocketmq.config.dataPath&#125;/users.properties if the login is requiredrocketmq.config.loginRequired=false 编译打包mvn clean package -Dmaven.test.skip=true 运行java -jar rocketmq-console-ng-1.0.1.jar 访问地址监控主页：http://localhost:8080","categories":[{"name":"rocketmq","slug":"rocketmq","permalink":"http://yoursite.com/categories/rocketmq/"}],"tags":[{"name":"rocketmq","slug":"rocketmq","permalink":"http://yoursite.com/tags/rocketmq/"},{"name":"rocketmq-console","slug":"rocketmq-console","permalink":"http://yoursite.com/tags/rocketmq-console/"}]},{"title":"linux常用命令","slug":"shell","date":"2019-05-09T12:45:00.000Z","updated":"2019-05-09T12:55:31.451Z","comments":false,"path":"2019/05/09/shell/","link":"http://yoursite.com/post/shell/","permalink":"http://yoursite.com/2019/05/09/shell/","excerpt":"","text":"基本命令 列出文件 ls 参数 目录名 例: 看看驱动目录下有什么:ls /System/Library/Extensions 参数 -w 显示中文，-l 详细信息， -a 包括隐藏文件 转换目录 cd 例：想到驱动目录下溜达一圈 cd /System/Library/Extensions 建立新目录 mkdir 目录名 例：在驱动目录下建一个备份目录backup mkdir /System/Library/Extensions/ backup 拷贝文件 cp 参数 源文件 目标文件 例：想把桌面的Natit.kext 拷贝到驱动目录中 cp -R /User/用户名/Desktop/Natit.kext /System/Library/Extensions 参数R表示对目录进行递归操作 删除文件 rm 参数 文件 例：想删除驱动的缓存 rm -rf /System/Library/Extensions.kextcache 参数－rf 表示递归和强制，千万要小心使用，如果执行了 rm -rf / 你的系统就全没了 移动文件 mv 文件 例：想把AppleHDA.Kext 移到桌面 mv /System/Library/Extensions/AppleHDA.kext /User/用户名/Desktop 文本编辑 nano 文件名 例：编辑natit Info.plist nano /System/Library/Extensions/Natit.kext/Info.plist 目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 diff 比较并显示两个文件的差异 diff file1 file2 sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的几条命令及编号 history r 重复执行最近执行过的某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w","categories":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/categories/shell/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"适配器模式","slug":"设计模式","date":"2019-05-07T01:00:00.000Z","updated":"2019-05-11T06:25:31.140Z","comments":false,"path":"2019/05/07/设计模式/","link":"http://yoursite.com/post/设计模式/","permalink":"http://yoursite.com/2019/05/07/设计模式/","excerpt":"","text":"适配器模式有两个编译好的无源码的类，类a需要一个特定的功能才能可用。这个功能需要实现接口a。但是类b恰好有这个功能，但是实现的是接口b，这时需要写一个适配器。1234567891011public interface XmlReader&#123; public InputStream xmlReader();&#125;public interface ReaderXml&#123; public InputStream readerXml();&#125;public class Adapter implements XmlReader extends B&#123; public InputStream xmlReader()&#123; return readerXml(); &#125;&#125; 适配器模式所涉及的角色 目标（CTarget） 定义一个客户端使用的特定接口 客户（CClient） 使用目标接口，与目标接口一致的对象合作 被适配者（CAdaptee） 一个现存需要匹配的接口 适配器（CAdapter） 负责将CAdaptee接口转成CTarget接口适配器分为对象适配器和类适配器 对象适配器包含一个适配器者的引用 类适配器：适配器内部调用他所继承的适配者的方法 EG 电脑接口 插座","categories":[{"name":"Design pattern","slug":"Design-pattern","permalink":"http://yoursite.com/categories/Design-pattern/"}],"tags":[{"name":"Adapter Pattern","slug":"Adapter-Pattern","permalink":"http://yoursite.com/tags/Adapter-Pattern/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-05T01:00:00.000Z","updated":"2019-05-05T01:20:06.648Z","comments":false,"path":"2019/05/05/hello-world/","link":"http://yoursite.com/post/hello-world/","permalink":"http://yoursite.com/2019/05/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}