{"meta":{"title":"yuanyujin's blog","subtitle":null,"description":null,"author":"yuanyujin","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"http and https","slug":"httpandhttps","date":"2019-05-31T13:10:00.000Z","updated":"2019-05-31T14:47:52.062Z","comments":false,"path":"2019/05/31/httpandhttps/","link":"http://yoursite.com/post/httpandhttps/","permalink":"http://yoursite.com/2019/05/31/httpandhttps/","excerpt":"","text":"网络层结构 OSI是指Open System Interconnect，意为开放式系统互联。 TCP/IP是指传输控制协议/网间协议，是目前世界上应用最广的协议 对应tcp/ip层 osi各层功能 网络协议 应用层 应用程序（电子邮件、文件服务）、用户接口 HTTP、FTP、TFTP、NFS 应用层 数据的表示、压缩和加密（数据格式化、代码转换、数据加密） TELNET、SNMP 应用层 建立、管理和终止会话 SMTP、DNS 传输层 提供端到端可靠报文传递和错误恢复 TCP、UDP 国际互联层 提供数据包从源到宿的传递和网际交互 IP、ICMP、ARP、RARP、UUCP 网络接口层 将比特组装成桢和点到点传递 FDDI、SLIP、PPP、PDN 网络接口层 传输比特流，以二进制数据形式在物理媒体上传输数据 ISO2110、IEEE802、IEEE802.2 两种模型的区别 OSI采用七层模型，TCP/IP采用四层模型。 TCP/IP网络接口层没有真正的定义，只是概念性的描述。OSI把它分为2层，每一层功能详尽。 在协议开发之前，就有了OSI模型，所以OSI模型具有共通性，而TCP/IP是基于协议建立的模型，不适用于非TCP/IP的网络。 实际应用中，OSI模型是理论上的模型，没有成熟的产品；而TCP/IP已经成为国际标准。 HTTP协议Http是基于TCP/IP协议的应用程序协议，不包括数据包的传输，主要规定了客户端和服务器的通信格式，默认使用80端口。 发展历史 1991年发布Http/0.9版本，只有Get命令，且服务端直返HTML格式字符串，服务器响应完毕就关闭TCP连接。 1996年发布Http/1.0版本，优点：可以发送任何格式内容，包括文字、图像、视频、二进制。也丰富了命令Get，Post，Head。请求和响应的格式加入头信息。缺点：每个TCP连接只能发送一个请求，而新建TCP连接的成本很高，导致Http/1.0新能很差。 1997发布Http/1.1版本，完善了Http协议，直至20年后的今天仍是最流行的版本。优点如下 引入持久连接，TCP默认不关闭，可被多个请求复用，对于一个域名，多数浏览器允许同时建立6个持久连接。 引入管道机制，即在同一个TCP连接中，可以同时发送多个请求，不过服务器还是按顺序响应。 在头部加入Content-Length字段，一个TCP可以同时传送多个响应，所以就需要该字段来区分哪些内容属于哪个响应。 分块传输编码，对于耗时的动态操作，用流模式取代缓存模式，即产生一块数据，就发送一块数据。 增加了许多命令，头信息增加Host来指定服务器域名，可以访问一台服务器上的不同网站。 2015年发布Http/2版本，它有几个特性：二进制协议、多工、数据流、头信息压缩、服务器推送。 http请求和响应格式request格式：12345678GET /barite/account/stock/groups HTTP/1.1QUARTZ-SESSION: MC4xMDQ0NjA3NTI0Mzc0MjAyNg.VPXuA8rxTghcZlRCfiAwZlAIdCADEVICE-TYPE: ANDROIDAPI-VERSION: 15Host: shitouji.bluestonehk.comConnection: Keep-AliveAccept-Encoding: gzipUser-Agent: okhttp/3.10.0 response格式123456789101112HTTP/1.1 200 OKServer: nginx/1.6.3Date: Mon, 15 Oct 2018 03:30:28 GMTContent-Type: application/json;charset=UTF-8Pragma: no-cacheCache-Control: no-cacheExpires: Thu, 01 Jan 1970 00:00:00 GMTContent-Encoding: gzipTransfer-Encoding: chunkedProxy-Connection: Keep-alive&#123;&quot;errno&quot;:0,&quot;dialogInfo&quot;:null,&quot;body&quot;:&#123;&quot;list&quot;:[&#123;&quot;flag&quot;:2,&quot;group_id&quot;:1557,&quot;group_name&quot;:&quot;港股&quot;,&quot;count&quot;:1&#125;,&#123;&quot;flag&quot;:3,&quot;group_id&quot;:1558,&quot;group_name&quot;:&quot;美股&quot;,&quot;count&quot;:7&#125;,&#123;&quot;flag&quot;:1,&quot;group_id&quot;:1556,&quot;group_name&quot;:&quot;全部&quot;,&quot;count&quot;:8&#125;]&#125;,&quot;message&quot;:&quot;success&quot;&#125; Host:指定服务器域名，可用来区分访问一个服务器上的不同服务 Connection：keep-alive（默认值）表示要求服务器不要关闭TCP。close表示明确要求关闭连接 Accept-Encoding：用户代理，是服务器能识别客户端的操作系统（Android，IOS，WEB）及相关的信息。作用是帮助服务器区分客户端，并且针对不同客户端让用户看到不同数据，做不同的操作。 Content-Type：服务器告诉客户端数据的格式，常见的值有text/plain、image/jpeg、image/png、video/mp4、application/json、application/zip，这些数据类型总称为MIMETYPE。 Content-Encodiing：chunked表示采用分块传输编码、有该字段则无需使用Content-Length字段。 Content-Length：声明数据的长度。请求和回应头部都可以使用该字段。 TCP三次握手http和https协议请求时都会通过tcp三次握手建立tcp连接。 第一次握手，A向B发送信息后，B收到消息，B可以确认A的发信能力和B的收信能力。 第二次握手，B向A发消息，A收到消息，A可确认A的发信能力和收信能力，A也可确认B的收信能力和发信能力。 第三次握手，A向B发送信息，B接收信息。B可确认A的收信能力和B的发信能力 ACK：响应标识，1表示响应，连接建立成功后，所有的报文段ACK的值都为1 SYN：连接标识，1表示建立连接，连接请求和连接接受报文段SYN=1，其他情况都是0 FIN：关闭连接标识，1标识关闭连接，关闭请求和关闭接受报文段FIN=1，其他情况都是0，跟SYN类似。 seq number：序号，一个随机数X，请求报文段中会有该字段，响应报文段没有 ack number：应答号，值为请求seq+1，即X+1，除了连接请求和连接接受响应报文段没有该字段，其他的报文段都有该字段。 三次握手具体流程 第一次握手：建立连接请求。客户端发送连接请求报文段，将SYN置为1，seq为随机数x。然后，客户端进入SYN_SEND状态，等待服务器确认。 第二次握手：确认连接请求。服务器收到客户端的SYN报文段，需要对该请求进行确认，设置ack=x+1（即客户端seq+1）。同时自己也要发送SYN请求信息，即SYN置为1，seq=y。服务器将SYN和ACK信息放在一个报文段中，一并发送给客户端，服务器进入SYN_RECV状态。 第三次握手：客户端收到SYN+ACK报文段，将ack设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕，客户端和服务券进入ESTABLISHED状态，完成Tcp三次握手。 数据传输完毕，需要断开连接，断开连接需要经历四次挥手 第一次挥手：主机1（可以是客户端或服务器），设置seq和ack向主机2发送一个FIN报文段，此时主机1进入FIN_WAIT_1状态，表示没有数据要发送给主机2了 第二次挥手：主机2收到主机1的FIN报文段，向主机1回应一个ACK报文段，表示同意关闭请求，主机1进入FIN_WAIT_2状态。 第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，主机2进入LAST_ACK状态。 第四次挥手：主机1收到主机2的FIN报文段，想主机2回应ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段后，关闭连接。此时主机1等待主机2一段时间后，没有收到回复，证明主机2已经正常关闭，主机1页关闭连接。 Https协议/SSL协议Https协议是以安全为目标的Http通道，简单来说就是Http的安全版。主要是在Http下加入SSL层（现在主流的是SLL/TLS），SSL是Https协议的安全基础。Https默认端口号为443。 http风险 窃听风险：Http采用明文传输数据，第三方可以用获知通信内容 篡改风险：第三方可以修改通信内容 冒充风险：第三方可以冒充他人身份进行通信 SSL/TLS协议就是为了解决这些风险而设计 所有信息加密传输，三方窃听通信内容 具有校验机制，内容一旦被篡改，通信双发立刻会发现 配备身份证书，防止身份被冒充 SSL发展史 1994年NetSpace公司设计SSL协议（Secure Sockets Layout）1.0版本，但未发布。 1995年NetSpace发布SSL/2.0版本，很快发现有严重漏洞 1996年发布SSL/3.0版本，得到大规模应用 1999年，发布了SSL升级版TLS/1.0版本，目前应用最广泛的版本 2006年和2008年，发布了TLS/1.1版本和TLS/1.2版本 SSL原理及运行过程SSL/TLS协议基本思路是采用公钥加密法（最有名的是RSA加密算法）。大概流程是，客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文，用自己的私钥解密。 为了防止公钥被篡改，把公钥放在数字证书中，证书可信则公钥可信。公钥加密计算量很大，为了提高效率，服务端和客户端都生成对话秘钥，用它加密信息，而对话秘钥是对称加密，速度非常快。而公钥用来机密对话秘钥。 过程 客户端给出协议版本号、一个客户端随机数A（Client random）以及客户端支持的加密方式 服务端确认双方使用的加密方式，并给出数字证书、一个服务器生成的随机数B（Server random） 客户端确认数字证书有效，生成一个新的随机数C（Pre-master-secret），使用证书中的公钥对C加密，发送给服务端 服务端使用自己的私钥解密出C 客户端和服务器根据约定的加密方法，使用三个随机数ABC，生成对话秘钥，之后的通信都用这个对话秘钥进行加密。 SSL证书SSL证书是一个二进制文件，里面包含经过认证的网站公钥和一些元数据，需要从经销商购买。 证书按照认证级别分类 域名认证（DV=Domain Validation）：最低级别的认证，可以确认申请人拥有这个域名 公司认证（OV=Organization Validation）：确认域名所有人是哪家公司，证书里面包含公司的信息 扩展认证（EV=Extended Validation）：最高级别认证，浏览器地址会显示公司名称 按覆盖范围分类 单域名证书：只能用于单域名 foo.com证书不用于www.foo.com 通配符证书：可用于某个域名及所有一级子域名，比如*.foo.com的证书可用于foo.com，也可以用于www.foo.com 多域名证书：可用于多个域名，比如foo.com和bar.com 认证级别越高，覆盖范围越广的证书，价格越贵。也有免费的证书，为了推广Https，电子前哨基金会成立了Let’s Encrypt提供免费证书。 RSA加密和DH加密加密算法分类 对称加密：甲方和乙方使用同一种加密规则对信息加解密 非对称加密：乙方生成两把秘钥（公钥和私钥）。公钥是公开的，任何人都可以获取，私钥是保密的，只存在于乙方手中。甲方获取公钥，然后用公钥加密信息，乙方得到密文后，用私钥解密。 Hash加密：Hash算法是一种单向密码体制，即只有加密过程，没有解密过程 对称加密算法加解密效率高，速度快，适合大数据量加解密。常见的堆成加密算法有DES、AES、RC5、Blowfish、IDEA 非对称加密算法复杂，加解密速度慢，但安全性高，一般与对称加密结合使用（对称加密通信内容，非对称加密对称秘钥）。常见的非对称加密算法有RSA、DH、DSA、ECC Hash算法特性是：输入值一样，经过哈希函数得到相同的散列值，但并非散列值相同则输入值也相同。常见的Hash加密算法有MD5、SHA-1、SHA-X系列 RSA加密算法Https协议就是使用RSA加密算法 RSA算法加密过程 DH加密算法DH也是一种非对称加密算法 DH加密算法过程 Http协议和Https协议的对比 https协议需要到CA申请证书，大多数情况下需要一定费用 Http是超文本传输协议，信息采用明文传输，Https则是具有安全性SSL加密传输协议 Http和Https端口号不一样，Http是80端口，Https是443端口 Http连接是无状态的，而Https采用Http+SSL构建可进行加密传输、身份认证的网络协议，更安全 Http协议建立连接的过程比Https协议快。因为Https除了Tcp三次握手，还要经过SSL握手。连接建立之后数据传输速度，二者无明显区别。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"}]},{"title":"java8新特性lambda表达式、方法引用、函数式接口、默认方式、静态方法","slug":"java8部分新特性","date":"2019-05-20T01:00:00.000Z","updated":"2019-05-20T00:52:05.100Z","comments":false,"path":"2019/05/20/java8部分新特性/","link":"http://yoursite.com/post/java8部分新特性/","permalink":"http://yoursite.com/2019/05/20/java8部分新特性/","excerpt":"","text":"lambda 表达式线程的用法原始的线程用法 1234567//使用匿名内部类的方式启动多线程new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;这是使用匿名内部类的方式。。。&quot;); &#125;&#125;).start(); lambda表达式 1234//使用lambda表达式方式new Thread(() -&gt; &#123; System.out.println(&quot;这是使用lambda表达式的方式。。。&quot;);&#125;).start(); 遍历方式原始方式 12345//原始方式List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);for (int i : list) &#123; System.out.println(i);&#125; lambda表达式 1234//使用lambda表达式代替foreach循环Stream.of(1, 2, 3, 4, 5).forEach((x) -&gt; &#123; System.out.println(x);&#125;); 总结 12([参数可选，...]) -&gt; &#123;&#125; 方法引用方法引用其实是 lambda 表达式的部分的简化。1234567891011121314151617181920212223242526@Testpublic void test_method_reference() &#123; //使用lambda表达式 Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;) .map(s -&gt; s.length()) //lambda .forEach((x) -&gt; &#123; System.out.println(x); &#125;); //使用静态方法引用 Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;) .map(String::length) //静态方法引用 .forEach((x) -&gt; &#123; System.out.println(x); &#125;); //使用实例方法引用 Stream.of( new ClassMate(&quot;1&quot;, &quot;欧阳思海&quot;), new ClassMate(&quot;2&quot;, &quot;sihai&quot;) ).map(ClassMate::getName)//实例方法引用 .forEach(x -&gt; &#123; System.out.println(x); &#125;);&#125; 第一个使用lambda表达式获取每个字符串的长度s -&gt; s.length()第二个使用静态方法获取每个字符串的长度String::length第三个使用实例方法引用ClassMate::getName 解释 map方法是映射的意思 forEach方法是遍历每一个元素 总结 使用方法 类名::方法 方法可以是静态方法和实例方法 构造函数引用123456789101112@Testpublic void test_method_reference2() &#123; //使用lambda表达式 Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;) .map(s -&gt; new ClassMate(s)) //lambda .collect(Collectors.toList()); //使用构造函数引用 Stream.of(&quot;A&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;DDDD&quot;, &quot;FFFFF&quot;) .map(ClassMate::new) //构造函数引用,由上下文决定用哪一个构造函数 .collect(Collectors.toList());&#125; 第一个我们使用的是 lambda 表达式进行创建对象的 s -&gt; new ClassMate(s)。 第二个我们使用的是构造函数引用创建对象的 ClassMate::new 。 我们发现构造函数引用：类名::new ，然后对于使用哪一个构造函数是由上下文决定的，比如有一个参数和两个参数和无参数的构造函数，会自动确定用哪一个。 接口在 Java 8 之前的接口是不能有实现的，只能定义抽象方法，然而，在 Java 8 以后，增加了一个新的功能，可以添加实现，可以定义默认方法，可以定义静态方法。 函数式接口在一个接口中我们以 @FunctionalInterface 注解声明一个接口，并且接口中只有一个抽象方法，那么我们就叫做这是一个函数式接口。 12345@FunctionalInterfacepublic interface FunctionalInterfaceTest &#123; //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口 void test(String s);&#125; 默认方法默认方法很简单，用 default 声明即可。 12345678910@FunctionalInterfacepublic interface FunctionalInterfaceTest &#123; //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口 void test(String s); //默认方法 default String getStr()&#123; return null; &#125;&#125; 静态方法123456789101112131415@FunctionalInterfacepublic interface FunctionalInterfaceTest &#123; //继承接口后，又加了新的抽象方法，这个接口就不再是函数式接口 void test(String s); //静态方法 static String getStr()&#123; return null; &#125; //错误用法 default static String getStr3()&#123; return null; &#125;&#125; 实现的静态方法，用 static 声明。 注意不能同时使用 default 和 static 声明。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Lambda","slug":"Lambda","permalink":"http://yoursite.com/tags/Lambda/"}]},{"title":"Field类","slug":"Field","date":"2019-05-18T12:00:00.000Z","updated":"2019-05-18T14:05:13.713Z","comments":false,"path":"2019/05/18/Field/","link":"http://yoursite.com/post/Field/","permalink":"http://yoursite.com/2019/05/18/Field/","excerpt":"","text":"Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。 Field 成员变量的介绍 每个成员变量有类型和值。java.lang.reflect.Field 为我们提供了获取当前对象的成员变量的类型，和重新设值的方法。 获取变量的类型类中的变量分为两种类型：基本类型和引用类型： 基本类型（ 8 种） 整数：byte, short, int, long 浮点数：float, double 字符：char 布尔值：boolean 引用类型 所有的引用类型都继承自 java.lang.Object 类，枚举，数组，接口都是引用类型 java.io.Serializable 接口，基本类型的包装类（比如 java.lang.Double）也是引用类型 java.lang.reflect.Field 提供了两个方法获去变量的类型： Field.getType()：返回这个变量的类型 Field.getGenericType()：如果当前属性有签名属性类型就返回，否则就返回 Field.getType() field.getType()和field.getGenericType()的区别就是返回类型不一样 获取成员变量的修饰符成员变量可以被以下修饰符修饰： 访问权限控制符：public, protected, private 限制只能有一个实例的：static 不允许修改的：final 不会被序列化：transient 线程共享数据的一致性：volatile 注解 类似获取 Class 的修饰符，我们可以使用 Field.getModifiers() 方法获取当前成员变量的修饰符。返回 java.lang.reflect.Modifier 中定义的整形值。然后使用 Modifier.toString(int mod)解码成字符串 由于 Field 间接继承了 java.lang.reflect.AnnotatedElement ，因此运行时也可以获得修饰成员变量的注解，当然前提是这个注解被 java.lang.annotation.RetentionPolicy.RUNTIME 修饰。 获取和修改成员变量的值拿到一个对象后，我们可以在运行时修改它的成员变量的值，对运行时来说，反射修改变量值的操作和类中修改变量的结果是一样的。 基本类型的getter方法 12345678910111213141516byte getByte(Object obj) 获取一个静态或实例 byte 字段的值。 int getInt(Object obj) 获取 int 类型或另一个通过扩展转换可以转换为 int 类型的基本类型的静态或实例字段的值。 short getShort(Object obj) 获取 short 类型或另一个通过扩展转换可以转换为 short 类型的基本类型的静态或实例字段的值。 long getLong(Object obj) 获取 long 类型或另一个通过扩展转换可以转换为 long 类型的基本类型的静态或实例字段的值。 float getFloat(Object obj) 获取 float 类型或另一个通过扩展转换可以转换为 float 类型的基本类型的静态或实例字段的值。 double getDouble(Object obj) 获取 double 类型或另一个通过扩展转换可以转换为 double 类型的基本类型的静态或实例字段的值。 boolean getBoolean(Object obj) 获取一个静态或实例 boolean 字段的值。 char getChar(Object obj) 获取 char 类型或另一个通过扩展转换可以转换为 char 类型的基本类型的静态或实例字段的值。 基本类型的setter 12345678910111213141516void setByte(Object obj, byte b) 将字段的值设置为指定对象上的一个 byte 值。 void setShort(Object obj, short s) 将字段的值设置为指定对象上的一个 short 值。 void setInt(Object obj, int i) 将字段的值设置为指定对象上的一个 int 值。 void setLong(Object obj, long l) 将字段的值设置为指定对象上的一个 long 值。 void setFloat(Object obj, float f) 将字段的值设置为指定对象上的一个 float 值。 void setDouble(Object obj, double d) 将字段的值设置为指定对象上的一个 double 值。 void setBoolean(Object obj, boolean z) 将字段的值设置为指定对象上的一个 boolean 值。 void setChar(Object obj, char c) 将字段的值设置为指定对象上的一个 char 值。 引用类型的getter 12Object get(Object obj) 返回指定对象上此 Field 表示的字段的值。 引用类型的setter 12void set(Object obj, Object value) 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。 再说一下setAccessible()方法，Field的setAccessible()方法是从AccessibleObject类继承而来的。AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了在使用时 取消默认 Java 语言访问控制检查的能力。一般情况下，我们并不能对类的私有字段进行操作，利用反射也不例外，但有的时候，例如要序列化的时候，我们又必须有能力去处理这些字段，这时候，我们就需要调用AccessibleObject上的setAccessible()方法来允许这种访问，而由于反射类中的Field，Method和Constructor继承自AccessibleObject，因此，通过在Field，Method和Constructor这些类上调用setAccessible()方法，我们可以操作这些字段无法访问的字段。 其他方法 boolean 123456boolean equals(Object obj) 将此 Field 与指定对象比较。 boolean isEnumConstant() 如果此字段表示枚举类型的元素，则返回 true；否则返回 false。 boolean isSynthetic() 如果此字段是复合字段，则返回 true；否则返回 false。 String 123456String getName() 返回此 Field 对象表示的字段的名称。 String toGenericString() 返回一个描述此 Field（包括其一般类型）的字符串。 String toString() 返回一个描述此 Field 的字符串。 其他 1234int hashCode() 返回该 Field 的哈希码。boolean equals(Object obj) 将此 Field 与指定对象比较。 equals()和hashCode() 12&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) 如果存在该元素的指定类型的注释，则返回这些注释，否则返回 null。 返回注释的方法： 12Annotation[] getDeclaredAnnotations() 返回直接存在于此元素上的所有注释。 返回字段所在的类或者接口的Class对象 12Class&lt;?&gt; getDeclaringClass() 返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段。 返回字段的类型（Type） 12Type getGenericType() 返回一个 Type 对象，它表示此 Field 对象所表示字段的声明类型。 返回修饰符编码 12int getModifiers() 以整数形式返回由此 Field 对象表示的字段的 Java 语言修饰符。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"Field","slug":"Field","permalink":"http://yoursite.com/tags/Field/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Method类","slug":"Method","date":"2019-05-18T12:00:00.000Z","updated":"2019-05-18T14:28:43.933Z","comments":false,"path":"2019/05/18/Method/","link":"http://yoursite.com/post/Method/","permalink":"http://yoursite.com/2019/05/18/Method/","excerpt":"","text":"Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。 一个完整方法包含的属性有： 方法上使用的注解 方法的修饰符 方法上定义的泛型参数 方法的返回值 方法名称 方法参数(泛型、注解) 方法抛出的异常 1234567891011121314151617@MyAnnotationpublic &lt;T&gt; boolean add(List&lt;T&gt; list,T...params)throws RuntimeException,Exception&#123; if(null==list)&#123; throw new RuntimeException(&quot;list=null&quot;); &#125; if(null==params)&#123; return false; &#125; //将参数添加到List集合中 if(null!=params)&#123; for(T t:params)&#123; list.add(t); &#125; &#125; return true;&#125; 注解：@MyAnnotation 修饰符：public 泛型参数：T 返回值：boolean 方法名：add 方法参数(泛型、注解)：List list，T…params 抛出的异常：RuntimeException，Exception 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130public class MethodTest &#123; /** * 一个完整方法包含的属性有： 方法上使用的注解、方法的修饰符、方法上定义的泛型参数、方法的返回值、方法名称、方法参数(泛型、注解)、方法抛出的异常 */ @MyAnnotation private &lt;T&gt; boolean add(@MyAnnotation List&lt;T&gt; list, T... params) throws RuntimeException, Exception &#123; if (null == list) &#123; throw new RuntimeException(&quot;list=null&quot;); &#125; if (null == params) &#123; return false; &#125; // 将参数添加到List集合中 if (null != params) &#123; for (T t : params) &#123; list.add(t); &#125; &#125; return true; &#125; public static void main(String[] args) throws Exception &#123; // 获取Method MethodTest obj = new MethodTest(); Class&lt;? extends MethodTest&gt; clazz = obj.getClass(); Method method = clazz.getDeclaredMethod(&quot;add&quot;, List.class, Object[].class); if (!method.isAccessible()) &#123; method.setAccessible(true); &#125; //获取方法基本信息 getMethodInfo(method); // 调用方法 List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); method.invoke(obj, arrayList, new String[] &#123; &quot;1&quot;, &quot;2&quot; &#125;); System.out.println(arrayList);//[1,2] //方法定义所在的类 Class&lt;?&gt; declaringClass = method.getDeclaringClass(); // 如果此方法是 bridge 方法，则返回 true； boolean bridge = method.isBridge(); //如果该方法是public非抽象非静态，且定义在接口中，则返回true boolean default1 = method.isDefault(); //false //如果此方法为复合方法，则返回 true； boolean synthetic = method.isSynthetic();//false // 如果将此方法的参数带有可变参数，则返回 true boolean varArgs = method.isVarArgs(); //true &#125; private static void getMethodInfo(Method method) &#123; // 1、获取方法上的注解 boolean annotationPresent = method .isAnnotationPresent(MyAnnotation.class); if (annotationPresent) &#123; MyAnnotation myAnnotation = method .getDeclaredAnnotation(MyAnnotation.class); &#125; // 2、方法的修饰符 int modifiers = method.getModifiers(); String modify = Modifier.toString(modifiers);// private // 3、方法上定义的泛型参数 TypeVariable&lt;Method&gt;[] typeParameters = method.getTypeParameters();// [T] // 4、方法的返回值 Class&lt;?&gt; returnType = method.getReturnType();// boolean Type genericReturnType = method.getGenericReturnType();// boolean // 5、方法名称 String name = method.getName(); // 6、方法参数 int parameterCount = method.getParameterCount();// 参数个数 2 // 方法参数——泛型 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); // 打印 [interface java.util.List, class [Ljava.lang.Object;] Type[] genericParameterTypes = method.getGenericParameterTypes(); // 打印 [java.util.List&lt;T&gt;, T[]] for (Type type : genericParameterTypes) &#123; if (type instanceof ParameterizedType) &#123; // 参数类型 System.out.println(&quot;ParameterizedType类型：&quot; + type); ParameterizedType parameterizedType = (ParameterizedType) type; Type[] actualTypeArguments = parameterizedType .getActualTypeArguments(); System.out.println(&quot;实际参数为：&quot; + Arrays.toString(actualTypeArguments)); for (Type actualType : actualTypeArguments) &#123; if (actualType instanceof WildcardType) &#123; WildcardType wildcardType = (WildcardType) actualTypeArguments[0]; System.out.println(&quot;实际参数为WildcardType类型：&quot; + wildcardType.getUpperBounds()); &#125; else if (actualType instanceof Class) &#123; System.out.println(&quot;实际参数为Class类型：&quot; + actualType); &#125; &#125; &#125; else if (type instanceof GenericArrayType) &#123; // 泛型数组类型 T[] GenericArrayType genericArrayType = (GenericArrayType) type; System.out.println(&quot;GenericArrayType类型：&quot; + genericArrayType.getGenericComponentType());//T &#125; else if (type instanceof TypeVariable) &#123; // 泛型变量 System.out.println(&quot;TypeVariable类型：&quot; + type); &#125; else if (type instanceof Class) &#123; // System.out.println(&quot;Class类型：&quot; + type); &#125; &#125; /* * 方法有2个参数，第一个参数list为ParameterizedType，实际参数为T， * 第二个参数为GenericArrayType泛型数组类型T[],数组元素类型为T */ //方法参数——注解 第一个参数使用了注解 Annotation[][] parameterAnnotations = method.getParameterAnnotations(); Annotation myAnnotation=parameterAnnotations[0][0]; //打印 @reflect.MyAnnotation(intValue=0) // 7、方法抛出的异常 Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes(); // 打印 [class java.lang.RuntimeException, class java.lang.Exception] Type[] genericExceptionTypes = method.getGenericExceptionTypes(); // 打印 [class java.lang.RuntimeException, class java.lang.Exception] &#125;&#125; Method类的invoke(Object obj,Object args[])方法接收的参数必须为对象,如果参数为基本类型数据,必须转换为相应的包装类型的对象。invoke()方法的返回值总是对象,如果实际被调用的方法的返回类型是基本类型数据,那么invoke()方法会把它转换为相应的包装类型的对象,再将其返回.","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Method","slug":"Method","permalink":"http://yoursite.com/tags/Method/"}]},{"title":"反射","slug":"反射","date":"2019-05-18T12:00:00.000Z","updated":"2019-05-18T13:41:24.846Z","comments":false,"path":"2019/05/18/反射/","link":"http://yoursite.com/post/反射/","permalink":"http://yoursite.com/2019/05/18/反射/","excerpt":"","text":"概念反射就是把java的各种成分映射成相应的java类 Class类的构建方法是private，由jvm创建 反射是java语言的一个特性，它允程序在运行时（注意不是编译的时候）来进行自我检查并且对内部的成员进行操作。例如它允许一个java的类获取他所有的成员变量和方法并且显示出来。 Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。 基本的 Java类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也表示为 Class 对象。Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的。 在没有对象实例的时候，主要有两种方法1234Class clazz1 = Role.class;Class clazz2 = Class.forName(&quot;yu.Role&quot;);Object o = cls1.newInstance(); 在第二种方法中，forName中的参数一定是完整的类名（包名+类名），并且这个方法需要捕获异常。现在得到cls1就可以创建一个Role类的实例了，利用Class的newInstance方法相当于调用类的默认的构造器。 常用方法 getConstructor(Class&lt;?&gt;… parameterTypes) 返回Constructor反映此Class 对象所表示的类的指定公共构造函数的对象。 getConstructors() 返回一个数组，其中包含Constructor反映此Class对象所表示的类的所有公共构造函数的 对象。 getDeclaredFields() 返回一个Field对象数组，反映由此Class对象表示的类或接口声明的所有字段 。 getDeclaredField(String name) 返回一个Field对象，该对象反映此Class 对象表示的类或接口的指定声明字段。 getDeclaredMethods() 返回一个数组，其中包含Method反映此Class对象所表示的类或接口的所有声明方法的对象，包括public，protected，default（包）访问和私有方法，但不包括继承的方法。 getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回一个Method对象，该对象反映此Class对象表示的类或接口的指定声明方法 。 getName() 返回此Class对象表示的实体名称（类，接口，数组类，基本类型或void），如String。 isPrimitive() 确定指定的Class对象是否表示基本类型。 例题 将所有String类型的成员变量里的b改成a。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.lang.reflect.Field;public class TestReflect &#123; public static void main(String[] args) throws SecurityException, NoSuchMethodException, NoSuchFieldException, IllegalArgumentException, Exception &#123; ReflectPointer rp1 = new ReflectPointer(3,4); changeBtoA(rp1); System.out.println(rp1); &#125; private static void changeBtoA(Object obj) throws RuntimeException, Exception &#123; Field[] fields = obj.getClass().getFields(); for(Field field : fields) &#123; //if(field.getType().equals(String.class)) //由于字节码只有一份,用equals语义不准确 if(field.getType()==String.class) &#123; String oldValue = (String)field.get(obj); String newValue = oldValue.replace(&apos;b&apos;, &apos;a&apos;); field.set(obj,newValue); &#125; &#125; &#125;&#125;class ReflectPointer &#123; private int x = 0; public int y = 0; public String str1 = &quot;ball&quot;; public String str2 = &quot;basketball&quot;; public ReflectPointer(int x,int y) &#123; super(); this.x = x; this.y = y; &#125; @Override public String toString() &#123; return &quot;ReflectPointer [str1=&quot; + str1 + &quot;, str2=&quot; + str2 + &quot;, str3=&quot; + str3 + &quot;]&quot;; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"reflection","slug":"reflection","permalink":"http://yoursite.com/tags/reflection/"}]},{"title":"rocketmq-console搭建","slug":"rocketmq-console","date":"2019-05-14T01:40:00.000Z","updated":"2019-05-14T01:53:06.008Z","comments":false,"path":"2019/05/14/rocketmq-console/","link":"http://yoursite.com/post/rocketmq-console/","permalink":"http://yoursite.com/2019/05/14/rocketmq-console/","excerpt":"","text":"源码 rocketmq的开源拓展项目rocketmq-externals 选择子模块rocketmq-console 修改配置 配置文件路径：rocketmq-console/src/main/resources/application.properties URL rocketmq.config.namesrvAddr=mq的ip:port 项目启动端口 server.port=8080 如果提示10909链接失败 rocketmq.config.isVIPChannel=修改为false eg：12345678910111213141516171819202122232425262728293031server.contextPath=#服务运行端口server.port=8080### SSL setting#server.ssl.key-store=classpath:rmqcngkeystore.jks#server.ssl.key-store-password=rocketmq#server.ssl.keyStoreType=PKCS12#server.ssl.keyAlias=rmqcngkey#spring.application.index=truespring.application.name=rocketmq-consolespring.http.encoding.charset=UTF-8spring.http.encoding.enabled=truespring.http.encoding.force=truelogging.config=classpath:logback.xml#if this value is empty,use env value rocketmq.config.namesrvAddr NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876#监听mq服务地址，多个用逗号隔开rocketmq.config.namesrvAddr=localhost:9876#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default truerocketmq.config.isVIPChannel=#rocketmq-console&apos;s data path:dashboard/monitorrocketmq.config.dataPath=/tmp/rocketmq-console/data#set it false if you don&apos;t want use dashboard.default truerocketmq.config.enableDashBoardCollect=true#set the message track trace topic if you don&apos;t want use the default onerocketmq.config.msgTrackTopicName=rocketmq.config.ticketKey=ticket#Must create userInfo file: $&#123;rocketmq.config.dataPath&#125;/users.properties if the login is requiredrocketmq.config.loginRequired=false 编译打包mvn clean package -Dmaven.test.skip=true 运行java -jar rocketmq-console-ng-1.0.1.jar 访问地址监控主页：http://localhost:8080","categories":[{"name":"rocketmq","slug":"rocketmq","permalink":"http://yoursite.com/categories/rocketmq/"}],"tags":[{"name":"rocketmq","slug":"rocketmq","permalink":"http://yoursite.com/tags/rocketmq/"},{"name":"rocketmq-console","slug":"rocketmq-console","permalink":"http://yoursite.com/tags/rocketmq-console/"}]},{"title":"linux常用命令","slug":"shell","date":"2019-05-09T12:45:00.000Z","updated":"2019-05-09T12:55:31.451Z","comments":false,"path":"2019/05/09/shell/","link":"http://yoursite.com/post/shell/","permalink":"http://yoursite.com/2019/05/09/shell/","excerpt":"","text":"基本命令 列出文件 ls 参数 目录名 例: 看看驱动目录下有什么:ls /System/Library/Extensions 参数 -w 显示中文，-l 详细信息， -a 包括隐藏文件 转换目录 cd 例：想到驱动目录下溜达一圈 cd /System/Library/Extensions 建立新目录 mkdir 目录名 例：在驱动目录下建一个备份目录backup mkdir /System/Library/Extensions/ backup 拷贝文件 cp 参数 源文件 目标文件 例：想把桌面的Natit.kext 拷贝到驱动目录中 cp -R /User/用户名/Desktop/Natit.kext /System/Library/Extensions 参数R表示对目录进行递归操作 删除文件 rm 参数 文件 例：想删除驱动的缓存 rm -rf /System/Library/Extensions.kextcache 参数－rf 表示递归和强制，千万要小心使用，如果执行了 rm -rf / 你的系统就全没了 移动文件 mv 文件 例：想把AppleHDA.Kext 移到桌面 mv /System/Library/Extensions/AppleHDA.kext /User/用户名/Desktop 文本编辑 nano 文件名 例：编辑natit Info.plist nano /System/Library/Extensions/Natit.kext/Info.plist 目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 diff 比较并显示两个文件的差异 diff file1 file2 sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送 回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的几条命令及编号 history r 重复执行最近执行过的某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w","categories":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/categories/shell/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"适配器模式","slug":"设计模式","date":"2019-05-07T01:00:00.000Z","updated":"2019-05-11T06:25:31.140Z","comments":false,"path":"2019/05/07/设计模式/","link":"http://yoursite.com/post/设计模式/","permalink":"http://yoursite.com/2019/05/07/设计模式/","excerpt":"","text":"适配器模式有两个编译好的无源码的类，类a需要一个特定的功能才能可用。这个功能需要实现接口a。但是类b恰好有这个功能，但是实现的是接口b，这时需要写一个适配器。1234567891011public interface XmlReader&#123; public InputStream xmlReader();&#125;public interface ReaderXml&#123; public InputStream readerXml();&#125;public class Adapter implements XmlReader extends B&#123; public InputStream xmlReader()&#123; return readerXml(); &#125;&#125; 适配器模式所涉及的角色 目标（CTarget） 定义一个客户端使用的特定接口 客户（CClient） 使用目标接口，与目标接口一致的对象合作 被适配者（CAdaptee） 一个现存需要匹配的接口 适配器（CAdapter） 负责将CAdaptee接口转成CTarget接口适配器分为对象适配器和类适配器 对象适配器包含一个适配器者的引用 类适配器：适配器内部调用他所继承的适配者的方法 EG 电脑接口 插座","categories":[{"name":"Design pattern","slug":"Design-pattern","permalink":"http://yoursite.com/categories/Design-pattern/"}],"tags":[{"name":"Adapter Pattern","slug":"Adapter-Pattern","permalink":"http://yoursite.com/tags/Adapter-Pattern/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-05T01:00:00.000Z","updated":"2019-05-05T01:20:06.648Z","comments":false,"path":"2019/05/05/hello-world/","link":"http://yoursite.com/post/hello-world/","permalink":"http://yoursite.com/2019/05/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Diary","slug":"Diary","permalink":"http://yoursite.com/categories/Diary/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]}